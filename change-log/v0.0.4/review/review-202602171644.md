# PR Review Summary — 2026-02-17 16:44

## レビュー対象

マルチウィンドウ対応機能の追加。11の新規tmuxコマンドハンドラ、フロントエンドのウィンドウタブUI、セッション環境変数操作、コントロールキー解析など広範囲の変更。

### 変更ファイル一覧（myT-x配下のみ）

| カテゴリ | ファイル | 変更概要 |
|----------|---------|---------|
| Backend - Router | `internal/tmux/command_router.go` | 11新規ハンドラ登録、`renamePane`テストシーム追加 |
| Backend - Pane | `internal/tmux/command_router_handlers_pane.go` | `handleKillPane`, `handleResizePane`, `applyPaneTitle`, `handleSelectPane` 拡張 |
| Backend - Pane Test | `internal/tmux/command_router_handlers_pane_test.go` | `TestHandleSelectPaneTitle`(8件), `TestHandleKillPane`(3件), `TestHandleResizePane`(4件) |
| Backend - Session | `internal/tmux/command_router_handlers_session.go` | `handleRenameSession`, `handleShowEnvironment`, `handleSetEnvironment`, `handleAttachSession` |
| Backend - Window | `internal/tmux/command_router_handlers_window.go` | `handleListWindows`, `handleRenameWindow`, `handleNewWindow`, `handleKillWindow`, `handleSelectWindow` |
| Backend - Window Test | `internal/tmux/command_router_handlers_window_test.go` | `TestHandleListWindows`(6件), `TestHandleRenameWindow`(4件), `TestHandleKillWindow`(3件), `TestHandleSelectWindow`(4件), `TestResolveWindowFromRequest`(5件) |
| Backend - Format | `internal/tmux/format.go` | `formatWindowLine`, `defaultWindowListFormat`, `window_active`変数 |
| Backend - KeyTable | `internal/tmux/key_table.go` | `parseControlKey` 追加 (C-{letter}サポート) |
| Backend - KeyTable Test | `internal/tmux/key_table_test.go` | `TestTranslateSendKeysControlKeys`(7件), `TestParseControlKey`(10件), `TestTranslateSendKeysEmptyInput` |
| Backend - SessionMgr | `internal/tmux/session_manager.go` | `nextWindowID`フィールド追加 |
| Backend - SessionMgr | `internal/tmux/session_manager_sessions.go` | Window IDをauto-incrementに変更 |
| Backend - SessionMgr | `internal/tmux/session_manager_env.go` | `SetSessionEnv`, `UnsetSessionEnv` 追加 |
| Backend - Events | `app_events.go` | ウィンドウ関連イベントのスナップショットトリガー追加 |
| Backend - Events Test | `app_events_test.go` | ウィンドウイベントのテストケース追加 |
| Backend - API | `app_window_api.go` | `AddWindow`, `RemoveWindow`, `RenameWindow` (変更なし、既存) |
| Shim | `cmd/tmux-shim/spec.go` | 新規コマンドのフラグ定義追加 |
| Shim Test | `cmd/tmux-shim/main_test.go` | shimテスト更新 |
| Frontend | `frontend/src/components/SessionView.tsx` | マルチウィンドウタブUI、アクティブウィンドウ切替 |
| Frontend | `frontend/src/api.ts` | `RemoveWindow`, `RenameWindow` import追加 |
| Frontend | `frontend/src/App.tsx` | 同上 |
| Frontend - CSS | `frontend/src/styles/layout.css` | ウィンドウタブバーのスタイル (~100行) |

---

## Critical Issues（3件）— マージ前に修正必須

### C-1. Wailsバインディング未生成 — `AddWindow` / `RemoveWindow` / `RenameWindow`

- **ファイル**: `frontend/wailsjs/go/main/App.d.ts`, `frontend/wailsjs/go/main/App.js`
- **観点**: ビルド / side-effects

**問題**: Go側の`app_window_api.go`に`AddWindow`/`RemoveWindow`/`RenameWindow`メソッドが存在するが、自動生成バインディングファイルにこれら3メソッドが含まれていない。フロントエンドの`api.ts`がインポートしているが、実行時に`undefined is not a function`となる。

**修正**: `wails generate module` を実行してバインディングを再生成する。

---

### C-2. `window_active` フォーマット変数がマルチウィンドウに非対応

- **ファイル**: `internal/tmux/format.go` — `lookupFormatVariable` 内 `case "window_active"`
- **観点**: code-review

**問題**: マルチウィンドウ機能が追加されたにもかかわらず、`window_active`は「最初のウィンドウ = アクティブ」というシングルウィンドウモデルのまま。`list-windows -F "#{window_active}"`を使うクライアントが実際のアクティブウィンドウを判定できない。

```go
case "window_active":
    // First window in session is considered active (single-window model).
    if len(session.Windows) > 0 && session.Windows[0] == window {
        return "1"
    }
    return "0"
```

**修正**: `TmuxSession`にアクティブウィンドウインデックスを追跡するフィールドを追加し、`SetActivePane`時にアクティブウィンドウも更新する。または、現在のアクティブペインが属するウィンドウをルックアップして判定する。

---

### C-3. `handleKillWindow` のイベントで古い `windowIdx` を送信

- **ファイル**: `internal/tmux/command_router_handlers_window.go` — `handleKillWindow`
- **観点**: code-review

**問題**: `RemoveWindow`後にスライスが詰められるため、イベントペイロードの`windowIndex`は無効値になっている可能性がある。フロントエンド側がインデックスベースでウィンドウを管理する場合にバグとなる。

```go
r.emitter.Emit("tmux:window-destroyed", map[string]any{
    "sessionName": sessionName,
    "windowIndex": windowIdx, // ← 削除後に無効
})
```

**修正**: `windowIdx`の代わりに`window.ID`（一意な識別子）をイベントペイロードに含める。`resolveWindowFromRequest`の返り値にウィンドウIDを追加するか、削除前にIDを取得する。

---

## Important Issues（12件）— 修正すべき

### I-1. `handleResizePane` で `layout-changed` イベント未発行

- **ファイル**: `internal/tmux/command_router_handlers_pane.go` — `handleResizePane`
- **観点**: silent-failure

**問題**: `ResizePane`成功後に`layout-changed`イベントが発行されない。`splitWindowResolved`や`handleKillPane`ではレイアウト変更時に発行しているため不整合。フロントエンドのレイアウトが更新されない。

**修正**: `ResizePane`成功後に`paneLayoutSnapshot`を取得して`tmux:layout-changed`をemit。

---

### I-2. `tmux:window-renamed` がデバウンスバイパスに含まれていない

- **ファイル**: `app_events.go` — `shouldBypassSnapshotDebounceForEvent`
- **観点**: code-review

**問題**: `window-created`と`window-destroyed`はバイパス対象だが`window-renamed`はデバウンスされる。`session-renamed`と`pane-renamed`はバイパス対象のため一貫性がない。

```go
// 現在 "tmux:window-renamed" が含まれていない
case "tmux:session-created", "tmux:session-destroyed", "tmux:session-renamed",
    "tmux:pane-focused", "tmux:pane-renamed",
    "tmux:window-created", "tmux:window-destroyed":
    return true
```

**修正**: `"tmux:window-renamed"` を追加。

---

### I-3. `handleAttachSession` で `resolvedSession` 変数が未使用（デッドコード）

- **ファイル**: `internal/tmux/command_router_handlers_session.go` — `handleAttachSession`
- **観点**: code-review

**問題**: `parseSessionName(target)`の結果を`resolvedSession`に格納するがデバッグログ以外で使われていない。`HasSession(target)`は内部で`parseSessionName`を呼ぶため動作はするが、不要変数が残っている。

```go
resolvedSession := parseSessionName(target)
if !r.sessions.HasSession(target) {  // ← resolvedSessionを使うべきか、変数を除去すべき
```

**修正**: `resolvedSession`を除去するか、`HasSession(resolvedSession)`に統一。

---

### I-4. SessionView.tsx — `onBlur`と`Enter`で`commitWindowRename`が二重呼び出し

- **ファイル**: `frontend/src/components/SessionView.tsx`
- **観点**: frontend

**問題**: Enter押下→`commitWindowRename(w)`→`setRenamingWindowId(null)`→inputアンマウント→`onBlur`発火→再度`commitWindowRename(w)`。名前変更時に`RenameWindow` APIが2回呼ばれる。

```tsx
onKeyDown={(e) => {
    if (e.key === "Enter") commitWindowRename(w);
    ...
}}
onBlur={() => commitWindowRename(w)}
```

**修正**: `commitWindowRename`内で`setRenamingWindowId`の状態を使って二重呼び出しをガード。

```tsx
const commitWindowRename = useCallback((w: WindowSnapshot) => {
    setRenamingWindowId((prev) => {
        if (prev === null) return null;
        const newName = renameValueRef.current.trim();
        if (newName && newName !== w.name) {
            void api.RenameWindow(sessionName, w.id, newName).catch(...);
        }
        return null;
    });
}, [sessionName]);
```

---

### I-5. SessionView.tsx — ウィンドウが1つの時に新規追加UIが存在しない

- **ファイル**: `frontend/src/components/SessionView.tsx`
- **観点**: frontend

**問題**: `windows.length > 1`の条件でタブバーを表示。ウィンドウが1つの場合、`+`ボタンも非表示となり新規ウィンドウ追加手段がUIに存在しない。

```tsx
{props.session.windows.length > 1 && (
    <div className="window-tab-bar">
```

**修正**: 条件を削除してタブバーを常時表示するか、1ウィンドウ時でも`+`ボタンだけ表示。

---

### I-6. SessionView.tsx — `activeWindow!` の非null assertion

- **ファイル**: `frontend/src/components/SessionView.tsx`
- **観点**: frontend

**問題**: early returnで`windows.length === 0`を弾いているが、`useMemo`の`activeWindow`とearly returnの構造が分離しているため、`!`によるassertionは脆弱。

```tsx
const currentWindow = activeWindow!;
```

**修正**: `if (!activeWindow)` のガードを追加し、non-null assertionを除去。

---

### I-7. `handleKillPane` — `GetSession`失敗時にログ・イベント無し

- **ファイル**: `internal/tmux/command_router_handlers_pane.go` — `handleKillPane`
- **観点**: silent-failure

**問題**: `KillPane`成功後、`GetSession(sessionName)`が`!ok`を返した場合、`layout-changed`イベントもデバッグログも出力されない。

```go
session, ok := r.sessions.GetSession(sessionName)
if ok {
    // ... layout snapshot
}
// else: 何も起きない
```

**修正**: `!ok`パスに`slog.Debug("[DEBUG-KILLPANE] session not found after kill, skipping layout event", ...)`を追加。

---

### I-8. `SetSessionEnv` — 空キーのサイレント受け入れ

- **ファイル**: `internal/tmux/session_manager_env.go` — `SetSessionEnv`
- **観点**: silent-failure

**問題**: `key`が空文字でもエラーなく`session.Env[""] = value`として格納される。

**修正**: `key`が空の場合にエラーを返す。

---

### I-9. `handleListWindows` — `-t`未指定時に全セッションのウィンドウを返す

- **ファイル**: `internal/tmux/command_router_handlers_window.go` — `handleListWindows`
- **観点**: code-review

**問題**: tmuxの`list-windows`では`-t`未指定時はカレントセッションのウィンドウを表示するが、ここでは`-a`と同じく全セッションを返す。tmux互換として使うクライアントが想定通りに動かない可能性がある。

```go
if allSessions || target == "" {
    sessions = r.sessions.ListSessions()
```

**修正**: `-t`未指定時は`CallerPane`から現在のセッションを推定し、そのセッションのウィンドウのみ返す。

---

### I-10. `handleNewWindow` — ロールバックの重複と1箇所目のターミナルクローズ漏れ

- **ファイル**: `internal/tmux/command_router_handlers_window.go` — `handleNewWindow`
- **観点**: code-review / simplify

**問題**: ロールバックロジックが2箇所に重複。1箇所目（snapshotエラー時）はターミナルクローズを行っていない。snapshotエラー時にはターミナルがまだアタッチされていないため実害は少ないが、コードの明確性と将来の安全性のために統一すべき。

**修正**: ローカルクロージャ`rollbackWindow`に抽出して統一。

---

### I-11. `handleKillPane` — ネスト5段の複雑なコードブロック

- **ファイル**: `internal/tmux/command_router_handlers_pane.go` — `handleKillPane`
- **観点**: simplify

**問題**: レイアウトスナップショット取得→イベント発行のロジックが5段ネストで可読性が低い。

**修正**: `emitLayoutChangedForSession(sessionName string)`ヘルパーに抽出してフラット化。`splitWindowResolved`にも同パターンがあるため再利用可能。

---

### I-12. CSS — `var(--fg)` が未定義の可能性

- **ファイル**: `frontend/src/styles/layout.css`
- **観点**: frontend

**問題**: `.window-tab:hover`と`.window-tab.active`で`color: var(--fg)`が使われているが、`--fg`は定義されていない。定義されているのは`--fg-main`と`--fg-dim`。

```css
.window-tab:hover {
    color: var(--fg);  /* 未定義 */
}
```

**修正**: `var(--fg)` → `var(--fg-main)` に変更。

---

## Suggestions（9件）— 改善提案

### S-1. `parseControlKey` が `C-[` (ESC) を未サポート

- **ファイル**: `internal/tmux/key_table.go`
- **問題**: tmuxでは`C-[`がESC (0x1b)として扱われるが、`sendKeysTable`には`"Escape"`しか登録されていない。`send-keys C-[`がサイレントに無視される。
- **修正**: `sendKeysTable`に`"C-["→{0x1b}`を追加。

### S-2. `handleNewWindow`のテストが存在しない

- **ファイル**: `internal/tmux/command_router_handlers_window_test.go`
- **問題**: 最も複雑なハンドラの一つでロールバック・環境変数マージ・send-keys など多くの分岐があるがテスト無し。
- **修正**: 正常系・`-d`フラグ・`-P -F`フラグ・存在しないセッション・アタッチ失敗のロールバック を最低限カバー。

### S-3. `formatWindowLine` のユニットテストが存在しない

- **ファイル**: `internal/tmux/format.go`
- **問題**: `handleListWindows`テストで間接テスト済みだが、nilウィンドウ・ActivePN範囲外等が未検証。
- **修正**: `TestFormatWindowLine` を作成。

### S-4. `window_active` フォーマット変数のテスト未作成

- **ファイル**: `internal/tmux/format_test.go`
- **問題**: マルチウィンドウ環境での最初/2番目ウィンドウの判定テスト無し。

### S-5. `TestHandleSelectWindow` でアクティブペイン状態変化が未検証

- **ファイル**: `internal/tmux/command_router_handlers_window_test.go`
- **問題**: イベント発行は検証しているが、実際のアクティブペインが変更されたか未検証。

### S-6. `TestHandleKillWindow`残存ウィンドウの内容が未検証

- **ファイル**: `internal/tmux/command_router_handlers_window_test.go`
- **問題**: 「kill one of two」ケースでセッション存在のみ確認だがウィンドウ数や名前は未検証。

### S-7. SessionView.tsx — WindowTabBarコンポーネント抽出

- **ファイル**: `frontend/src/components/SessionView.tsx`
- **問題**: コンポーネントが180行超でstate 3個+callback 5個がタブ管理に集中。
- **修正**: `WindowTabBar`コンポーネントに抽出してSRP遵守。

### S-8. `applyPaneTitle` — `target == nil`のサイレントリターン

- **ファイル**: `internal/tmux/command_router_handlers_pane.go`
- **問題**: 呼び出し元でnilチェック済みだが、将来の安全策としてデバッグログ追加推奨。

### S-9. 最後のウィンドウ閉じ操作に確認ダイアログなし

- **ファイル**: `frontend/src/components/SessionView.tsx`
- **問題**: 最後のウィンドウを閉じるとセッションが破壊される。確認UIの検討を推奨。

---

## Positive Observations（良い点）

1. **テーブル駆動テストの一貫した採用**: 全新規テストがテーブル駆動パターンで正常系・異常系を網羅
2. **ロールバック設計**: `handleNewWindow`/`splitWindowResolved`/`handleNewSession`で失敗時のクリーンアップが堅実
3. **イベント駆動設計の一貫性**: 全コマンドハンドラがイベント発行で終わるパターンが統一
4. **デバッグログプレフィックスの統一**: `[DEBUG-*]`形式で`grep`一括削除が容易
5. **テストシーム設計**: `renamePane`をフィールドとして切り出し、エラー注入テストを可能に
6. **`parseControlKey`の簡潔な実装**: テーブル列挙ではなく計算で解決
7. **best-effort方針の遵守**: `send-keys`の初期コマンド送信失敗時もセッション作成を継続
8. **`captureEmitter`の共有化**: テストヘルパーを一元管理、`EventNames()`メソッドも完備
9. **`app_window_api.go`のルーター委譲パターン**: 直接SessionManagerを触らず責務分離が適切
10. **クローン安全性**: `cloneSessionForRead`によるディープコピーでデータ競合を構造的に排除

---

## タスク整理・並列作業可否一覧

以下は、指摘事項ごとの修正タスクと並列作業の可否をまとめた表です。

### Critical タスク

| # | タスク | 対象ファイル | 推定作業量 | 並列可否 | 依存関係 | 備考 |
|---|--------|-------------|-----------|---------|---------|------|
| C-1 | Wailsバインディング再生成 | `frontend/wailsjs/go/main/App.*` | 小 (コマンド実行のみ) | ✅ 独立 | なし | `wails generate module` 実行 |
| C-2 | `window_active` のマルチウィンドウ対応 | `internal/tmux/format.go`, `session_manager.go` | 中 | ⚠️ C-3と並列可 | なし | active windowトラッキング追加が必要 |
| C-3 | `kill-window` イベントをIDベースに変更 | `internal/tmux/command_router_handlers_window.go` | 小 | ⚠️ C-2と並列可 | なし | `windowIndex` → `windowID` への変更 |

### Important タスク

| # | タスク | 対象ファイル | 推定作業量 | 並列可否 | 依存関係 | 備考 |
|---|--------|-------------|-----------|---------|---------|------|
| I-1 | `handleResizePane`に`layout-changed`イベント追加 | `command_router_handlers_pane.go` | 小 | ✅ 独立 | なし | I-11のヘルパー抽出と合わせると効率的 |
| I-2 | `window-renamed`をデバウンスバイパスに追加 | `app_events.go` | 小 (1行追加) | ✅ 独立 | なし | |
| I-3 | `handleAttachSession`のデッドコード除去 | `command_router_handlers_session.go` | 小 (数行) | ✅ 独立 | なし | |
| I-4 | `commitWindowRename`の二重呼び出し防止 | `frontend/src/components/SessionView.tsx` | 小 | ✅ I-5, I-6と並列可 | なし | |
| I-5 | 1ウィンドウ時のタブバー表示 | `frontend/src/components/SessionView.tsx` | 小 | ⚠️ I-4と同ファイル | I-4の修正との競合に注意 | |
| I-6 | `activeWindow!` assertionの除去 | `frontend/src/components/SessionView.tsx` | 小 | ⚠️ I-4, I-5と同ファイル | I-4, I-5と同ファイル | |
| I-7 | `handleKillPane`の`GetSession`失敗ログ追加 | `command_router_handlers_pane.go` | 小 | ✅ I-1と並列可 | なし | |
| I-8 | `SetSessionEnv`の空キーバリデーション追加 | `session_manager_env.go` | 小 (数行) | ✅ 独立 | なし | |
| I-9 | `handleListWindows`のデフォルト動作修正 | `command_router_handlers_window.go` | 中 | ✅ 独立 | なし | CallerPaneからセッション推定 |
| I-10 | `handleNewWindow`ロールバック統合 | `command_router_handlers_window.go` | 小 | ⚠️ I-9と同ファイル | I-9と同ファイル | クロージャ抽出 |
| I-11 | `handleKillPane`ネスト解消 | `command_router_handlers_pane.go` | 小 | ⚠️ I-1, I-7と同ファイル | ヘルパー抽出後にI-1で再利用 | |
| I-12 | CSSの`var(--fg)`修正 | `frontend/src/styles/layout.css` | 小 (2行) | ✅ 独立 | なし | |

### 並列実行グループの推奨

| グループ | タスク | 同時作業者数 | 理由 |
|----------|--------|-------------|------|
| **A: バックエンド Pane** | I-1, I-7, I-11 | 1名 | 同一ファイル(`command_router_handlers_pane.go`) |
| **B: バックエンド Window** | C-3, I-9, I-10 | 1名 | 同一ファイル(`command_router_handlers_window.go`) |
| **C: バックエンド Format/Session** | C-2, I-8 | 1名 | 異なるファイルだが両方SessionManager関連 |
| **D: バックエンド Events/Session** | I-2, I-3 | 1名 | 異なるファイルで独立 |
| **E: フロントエンド** | I-4, I-5, I-6, I-12 | 1名 | SessionView.tsx + layout.css |
| **F: ビルド** | C-1 | 1名 | 独立（先にGoの変更が必要） |

**グループA〜Eは完全に並列実行可能**です。グループFはGoバックエンドの変更完了後に実行するのが望ましいが、バインディング再生成のみなら現状のGoコードでも実行可能です。

### 推奨実行順序

```
Phase 1 (並列):
  ├── グループA: Pane系修正 (I-1, I-7, I-11)
  ├── グループB: Window系修正 (C-3, I-9, I-10)
  ├── グループC: Format/Session修正 (C-2, I-8)
  ├── グループD: Events/Session修正 (I-2, I-3)
  └── グループE: フロントエンド修正 (I-4, I-5, I-6, I-12)

Phase 2 (Phase 1完了後):
  └── グループF: Wailsバインディング再生成 (C-1)

Phase 3 (Phase 2完了後):
  └── テスト実行 (go test ./...) で全体の整合性確認
```
