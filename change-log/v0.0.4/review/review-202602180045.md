# PR Review Summary — 2026-02-18 00:45

## 概要

**対象**: `myT-x/` 配下のコミット前変更  
**変更規模**: 42ファイル, +3,389行 / -134行  
**主要変更**: Window管理機能の追加（ActiveWindowID、マルチウィンドウ対応）

### レビューカテゴリ

| カテゴリ | 対象ファイル群 | レビュー結果 |
|---|---|---|
| A. SessionManager層 | session_manager*.go, format.go, key_table.go | Important 2件, Suggestion 4件 |
| B. CommandRouter層 | command_router*.go | Critical 1件, Important 3件, Suggestion 5件 |
| C. App層 | app_events.go, app_snapshot_delta.go, app_snapshot_metrics.go, app_status.go | Important 1件, Suggestion 2件 |
| D. フロントエンド | frontend/*, cmd/tmux-shim/* | Critical 2件, Important 7件, Suggestion 7件 |
| E. テスト品質 | 全*_test.goファイル | Important 16件, Suggestion 8件 |
| F. Window API | app_window_api.go, session_manager_windows.go | Critical 2件, Important 4件, Suggestion 4件 |

---

## Critical Issues（5件 — マージ前に修正必須）

### C-1. [command_router_handlers_window.go] `handleKillWindow` の nil pane チェック漏れ

`removedPanes` ループで `pane` 自体のnilチェックが欠けている。同ファイルの `handleNewWindow` ロールバック処理では `removedPane == nil || removedPane.Terminal == nil` と正しくガードされており、パターンが不一致。

```go
// 現在（パニックリスク）:
for _, pane := range removedPanes {
    if pane.Terminal != nil {

// 修正:
for _, pane := range removedPanes {
    if pane == nil || pane.Terminal == nil {
        continue
    }
```

**影響**: nil pane がスライスに含まれた場合にパニック

---

### C-2. [SessionView.tsx] ウィンドウタブのアクティブ判定がオブジェクト参照比較

`w === currentWindow` でオブジェクト参照を比較している。バックエンドからスナップショットが更新されるたびに新しいオブジェクトが生成されるため、同一参照である保証がない。

```tsx
// 現在:
w === currentWindow

// 修正:
w.id === currentWindow.id
```

`aria-selected={w === currentWindow}` にも同じ問題がある。

**影響**: スナップショット更新後にアクティブタブのハイライトが外れる

---

### C-3. [SessionView.tsx] zoomPaneIdがウィンドウ切替時にクリアされない

ウィンドウAのペインをズームした状態でウィンドウBに切り替えると、`zoomPaneId` が残ったまま `LayoutRenderer` に渡され、ウィンドウBには存在しないペインIDでズーム表示が試みられる。

**修正**: `activeWindow` の変化時に `setZoomPaneId(null)` を呼ぶ `useEffect` を追加。

---

### C-4. [app_window_api.go] TOCTOU: `RemoveWindow` における windowID→index→target→再解決の競合

`RemoveWindow` は `WindowIndexInSession(sessionName, windowID)` でIDをインデックスに変換し、`"session:index"` 形式のターゲット文字列としてルーターに渡す。ルーターは再度インデックスからウィンドウを解決する。

この2ステップの間に並行リクエストがウィンドウを追加・削除するとインデックスがシフトし、意図しないウィンドウが削除される可能性がある。

`RenameWindow` も同一パターン。

```
修正案: RouterにwindowIDを直接渡す仕組みを追加するか、
RemoveWindowByID / RenameWindowByID を直接呼び出してルーターバイパスする。
```

---

### C-5. [app_window_api.go] `RemoveWindow` で最後のウィンドウ削除時に `activeSess` が更新されない

最後のウィンドウを削除するとセッション自体が破棄されるが、`App.activeSess` は更新されない。対照的に `KillSession` では明示的に `setActiveSessionName("")` を呼んでいる。

```go
// KillSession にはあるが、RemoveWindow にはない:
if a.getActiveSessionName() == sessionName {
    a.setActiveSessionName("")
}
```

**影響**: `activeSess` が存在しないセッション名を保持し続け後続操作で不整合

---

## Important Issues（33件 — 修正推奨）

### I-1. [session_manager_env.go] `SetSessionEnv` が値の変更有無を確認せず常に mutation マーク

`UnsetSessionEnv` はキー存在チェック後にマーク。`SetRootPath` は変更前後比較。`SetSessionEnv` だけが一貫性を欠く。

```go
// 推奨修正:
if prev, ok := session.Env[key]; ok && prev == value {
    return nil
}
session.Env[key] = value
m.markStateMutationLocked()
```

### I-2. [session_manager_pane_lifecycle.go] `killPaneLocked` の `fallbackWindowIDNearIndex` に常に `preferredIdx=0`

`removeWindowAtIndexLocked` では削除位置付近を優先しているのに対し、`killPaneLocked` では常にインデックス0。実害は限定的だが設計不整合。

### I-3. [command_router_handlers_window.go] `handleKillWindow` の `emitLayoutChangedForSession` に削除済みwindowIDを渡している

`RemoveWindowByID` で既に削除された後の `windowID` を `preferredWindowID` として渡している。存在しないIDなので `firstPaneInSession` にフォールバックする。残存ウィンドウのIDか `-1` を渡すべき。

### I-4. [command_router_handlers_pane.go] `splitWindowResolved`/`handleNewSession` で send-keys 前に `Terminal == nil` チェック不統一

`handleNewWindow` では `pane.Terminal == nil` を防御的にチェック。`splitWindowResolved` と `handleNewSession` ではチェックなし。パターン不統一。

### I-5. [command_router_handlers_session.go] `handleAttachSession` で `parseSessionName` を二重呼び出し

`GetSession` 内部でも `parseSessionName` が呼ばれるため二重処理。`handleListWindows` にも同パターン。

### I-6. [app_status.go] `windowIdx` 変数名の不正確さ

`windowIdx = activeWindow.ID` で Window ID を代入しているが変数名は `windowIdx`。`windowID` にリネームすべき。

### I-7. [SessionView.tsx] `window.confirm()` 使用

Wailsアプリではネイティブの`confirm`ダイアログが適切に動作しない場合がある。カスタムモーダルの使用を推奨。

### I-8. [usePrefixKeyMode.ts] Ref同期パターンの冗長性

4つの `useEffect` + `useRef` ペアで同期。`useTmuxStore.getState()` に統一すれば排除可能。

### I-9. [usePrefixKeyMode.ts] Prefixモードのペイン移動がリニア

矢印キーでのペイン移動が配列インデックスベース。実際の空間配置とは無関係で直感的でない。

### I-10. [App.tsx] `SetActiveSession` の無駄なラウンドトリップ

初回読み込み時にバックエンドから取得した値をまたバックエンドに送信する。前回送信値との比較ガードが必要。

### I-11. [SessionView.tsx] ウィンドウリネーム状態管理が複雑

5つのref/stateの組み合わせ。カスタムフックへの抽出を推奨。

### I-12. [api.ts] `GetValidationRules` の型キャスト

`as Promise<ValidationRules>` は型アサーション。実際の型不一致時にランタイムエラー。

### I-13. [models.ts] `SessionSnapshot.created_at` 型が `any`

自動生成ファイル。型安全性が低い。

### I-14. [app_window_api.go] `RemoveWindow` でTerminal停止が不完全

`stopOutputBuffer(paneID)` が個別呼び出しされず `detachStaleOutputBuffers` で一括処理。KillPaneとパターン不統一。

### I-15. [app_window_api.go] ルーターエラーを丸める

`errors.New(resp.Stderr)` でエラー再構築するため構造化エラー情報が失われる。`RemoveWindow`, `RenameWindow` も同様。

### I-16. [session_manager_windows.go] `AddWindow` のウィンドウ名デフォルト値がユニークでない可能性

`len(session.Windows)` をウィンドウ名に使用。削除→追加で同名になりうる。

### I-17〜I-33. テスト漏れ（詳細は後述のテスト漏れ一覧参照）

---

## Suggestions（30件 — 改善提案）

### S-1. [session_manager_pane_io.go, session_manager_targets.go] RLock → Lock のパフォーマンスノート

高頻度メソッドの排他ロック化。将来的に「RLock試行 → repair時Lock昇格」パターンを検討。

### S-2. [key_table.go] sendKeysTable と parseControlKey の重複

`C-c`, `C-d`, `C-z` がテーブルにも `parseControlKey` にも存在。テーブル側の3エントリを削除して一元化推奨。

### S-3. [format.go] lookupFormatVariable のスレッド安全性コメント欠如

`expandFormat`/`lookupFormatVariable` の godoc に "caller must ensure data is cloned or lock-protected" と明記を推奨。

### S-4. [session_manager_windows.go] AddWindow が ActiveWindowID を更新しない

新規ウィンドウ追加時に ActiveWindowID 非変更は仕様か。コメントで設計意図を明記推奨。

### S-5. [command_router_handlers_pane.go] `applyPaneTitle` 内の `renamePane == nil` チェックは不要

`NewCommandRouter` で必ず設定されるため構造上 nil にならない。dead code。

### S-6. [command_router_handlers_window.go] `resolveWindowFromRequest` はテスト専用

本番ハンドラは全て `resolveWindowIDFromRequest` を使用。テスト専用であることを明記推奨。

### S-7. [command_router_handlers_session.go] `handleShowEnvironment` の `-t` 未指定時の仕様コメント

実tmuxでは現在セッションの環境変数が表示される。myT-x で空返却は意図的であればコメント推奨。

### S-8. [command_router_handlers_window.go] `handleSelectWindow` のフォールバック複雑性

`GetPaneContextSnapshot` 失敗時のフォールバックが複雑。`slog.Warn` への昇格を検討。

### S-9. [app_events.go] emit/debounce bypass の差分理由のコメント

`pane-created` と `layout-changed` がバイパス対象外である設計意図をコメントで補記推奨。

### S-10. [app_snapshot_metrics.go] ベース定数84の根拠コメント

JSON鍵名オーバーヘッドとの乖離がある。導出根拠のコメントを推奨。

### S-11. [SessionView.tsx] コールバック関数群の共通パターン化

API呼出し→catchの同一パターンをヘルパー関数で共通化推奨。

### S-12. [spec.go] commandSpecs と commandOrder の一元管理

二重管理のリスク排除のため構造化データから両方を生成する設計を推奨。

### S-13. [types/tmux.ts vs models.ts] 二重型定義の存在

フィールド追加時の手動型定義更新漏れリスク。

### S-14. [parse.go] `select-window`, `kill-window` の `-t` 必須チェック漏れ（shimレベル）

`validateRequired` に含まれていない。意図的か要確認。

### S-15. [layout.css] CSSカスタムプロパティのフォールバック不一致

フォールバック値の有無が混在。

### S-16. [usePrefixKeyMode.ts] プレフィックスタイマー1200msのハードコード

定数抽出推奨。

### S-17. [app_window_api.go] Window API でルーターバイパスパターンに統一

Pane API は SessionManager 直接呼出し + App層イベント発行。Window API はルーター経由。統一推奨。

### S-18. [app_window_api.go] `AddWindow` に windowName パラメータ追加

フロントエンドからウィンドウ命名を可能にする。

### S-19〜S-30. テスト改善提案（詳細は後述）

---

## テスト漏れ一覧

### ハンドラレベルのテスト漏れ

| 関数名 | テスト有無 | 備考 |
|---|---|---|
| `handleAttachSession` | ❌ なし | - |
| `handleShowEnvironment` | ❌ なし | - |
| `handleSetEnvironment` | ❌ なし | - |
| `handleRenameSession` | ❌ なし | - |
| `handleKillPane` | ✅ あり | command_router_handlers_pane_test.go |
| `handleResizePane` | ✅ あり | command_router_handlers_pane_test.go |
| `handleSelectPane` (タイトル更新) | ✅ あり | 一部エッジケース未カバー |
| `handleListPanes` | ❌ なし | - |
| `handleDisplayMessage` | ❌ なし | - |
| `handleSendKeys` | ❌ なし | TranslateSendKeysの単体テストのみ |
| `handleSplitWindow` | ⚠️ 不十分 | workDirフォールバックのみ |
| `handleHasSession` | ❌ なし | - |
| `handleListSessions` | ❌ なし | - |
| `handleNewSession` | ❌ なし | - |

### SessionManagerレベルのテスト漏れ

| メソッド名 | テスト有無 | 備考 |
|---|---|---|
| `RenameSession` | ❌ なし | ハンドラ経由の間接テストのみ |
| `ResizePane` | ❌ なし | - |
| `AddWindow` | ❌ なし | ハンドラ経由の間接テストのみ |
| `RemoveWindow`/`RemoveWindowByID` | ❌ なし | - |
| `RenameWindowByID` | ❌ なし | - |

### ユーティリティ関数のテスト漏れ

| 関数名 | テスト有無 | 備考 |
|---|---|---|
| `emitLayoutChangedForSession` | ❌ なし | 間接テストのみ |
| `paneForLayoutSnapshot` | ❌ なし | - |
| `activeWindowInSessionLocked` | ⚠️ 不十分 | ResolveTarget経由のみ。nil/空ケース未テスト |
| `formatSessionLine` | ❌ なし | - |
| `formatPaneLine` | ❌ なし | - |

---

## Strengths（良い点）

1. **auto-repair パターン**: `activeWindowInSessionLocked` による ActiveWindowID の自動修復は堅牢な設計。検出→修復→ログの3段階が適切。

2. **clone保護**: `ResolveSessionTarget` が `cloneSessionForRead` を返すように変更。内部状態の意図しない変更を防止。

3. **フィールド数ガードテスト**: `reflect.NumField` による struct フィールド数チェックで、フィールド追加時の equal/estimate 関数更新漏れを検出。

4. **ロールバック設計**: `handleNewWindow` / `handleNewSession` のステージ別ロールバックが堅牢。

5. **イベント発行のロック外実行**: 全ハンドラでイベント発行がロック解放後に行われており、デッドロックリスクなし。

6. **IME対応**: `isImeTransitionalEvent` でIME変換中のキーイベントフィルタリング。

7. **tmux-shim の `runTransformSafe`**: パニックリカバリでリクエスト元状態復元する防御的設計。

8. **`SwapPanes` のレイアウトフォールバック**: `swapPaneIDsInLayout` が nil を返した場合に `rebuildLayoutFromPaneOrder` で再構築。

---

## タスク修正の並列作業可否表

以下の表は、各タスクが他タスクと並列で修正可能かどうかをまとめたものです。

| # | タスク | 対象ファイル | 優先度 | 並列作業 | 依存・競合関係 |
|---|---|---|---|---|---|
| C-1 | `handleKillWindow` nil チェック追加 | command_router_handlers_window.go | 🔴 Critical | ✅ 可能 | 独立した1行修正。他タスクと競合しない |
| C-2 | ウィンドウタブ参照比較→ID比較 | SessionView.tsx | 🔴 Critical | ✅ 可能 | フロントエンドのみ。バックエンドタスクと競合しない |
| C-3 | zoomPaneId のウィンドウ切替クリア | SessionView.tsx | 🔴 Critical | ⚠️ C-2と同ファイル | C-2と同一ファイルだが変更箇所は別。注意すれば並列可能 |
| C-4 | TOCTOU: RemoveWindow/RenameWindow | app_window_api.go, command_router* | 🔴 Critical | ❌ 単独作業 | ルーター/SessionManager/App層にまたがるリファクタリング。C-5と関連 |
| C-5 | activeSess 更新漏れ | app_window_api.go | 🔴 Critical | ❌ C-4と依存 | C-4のリファクタリングに含めて対応すべき |
| I-1 | SetSessionEnv mutation 最適化 | session_manager_env.go | 🟡 Important | ✅ 可能 | 独立した関数内修正 |
| I-2 | killPaneLocked の preferredIdx | session_manager_pane_lifecycle.go | 🟡 Important | ✅ 可能 | 独立した1行修正 |
| I-3 | emitLayoutChanged に削除済みID | command_router_handlers_window.go | 🟡 Important | ⚠️ C-1と同ファイル | C-1と同一ファイルだが変更箇所は別。注意すれば並列可能 |
| I-4 | Terminal nil チェック統一 | command_router_handlers_pane.go, handlers_session.go | 🟡 Important | ✅ 可能 | 各ファイル内の独立した修正 |
| I-5 | parseSessionName 二重呼び出し | command_router_handlers_session.go | 🟡 Important | ✅ 可能 | エラーメッセージのみ影響 |
| I-6 | windowIdx → windowID リネーム | app_status.go | 🟡 Important | ✅ 可能 | 変数名変更のみ。他と競合なし |
| I-14 | Terminal停止パターン統一 | app_window_api.go | 🟡 Important | ❌ C-4/C-5 と依存 | リファクタリングに含めて対応すべき |
| I-16 | ウィンドウ名デフォルト値 | session_manager_windows.go | 🟡 Important | ✅ 可能 | 独立した関数内修正 |
| S-2 | sendKeysTable 重複削除 | key_table.go | 🟢 Suggestion | ✅ 可能 | 独立したファイル |
| S-9 | emitイベント分類コメント追加 | app_events.go | 🟢 Suggestion | ✅ 可能 | コメント追加のみ |

### 推奨作業順序

```
Phase 1（並列可能グループ — 独立した修正）
├── 作業者A: C-1 → I-3（同一ファイル、順次）
├── 作業者B: C-2 → C-3（同一ファイル、順次）
├── 作業者C: I-1, I-2, I-6（各独立ファイル、並列可）
└── 作業者D: I-4, I-5（各独立ファイル、並列可）

Phase 2（依存関係のあるリファクタリング — 単独作業）
└── 作業者1人: C-4 + C-5 + I-14（app_window_api.go 全体リファクタリング）

Phase 3（テスト追加 — 並列可能）
├── 作業者A: ハンドラテスト追加
├── 作業者B: SessionManagerテスト追加
└── 作業者C: ユーティリティ関数テスト追加
```
