# コミット前 コードレビューレポート

**実行日時**: 2026-02-20 13:50:24
**対象ディレクトリ**: `myT-x/internal/workerutil/`, `myT-x/internal/wsserver/` (未コミットの追加・変更ファイル)

今回のレビューは、高負荷時および異常系の耐性に重点を置いたアーキテクチャや並行処理の安全性を確認するため、各種カテゴリー（エラーハンドリング、コード安全性、テスト、コメント）ごとに深い調査を行いました。

## 🔍 カテゴリ別 指摘事項

### 1. エラーハンドリング・サイレントフェイラー (Errors)
* **[hub.go: handleWS] WebSocketのデッドコネクション検知漏れ**
  * **指摘**: `handleWS` のリードポンプにおいて、`Ping/Pong` メッセージによる死活監視や `SetReadDeadline` が実装されていません。フロントエンド（Webview等）のプロセスが不意にクラッシュし、TCPクローズパケットが送られなかった場合、サーバ側のゴルーチンやリソース（コネクション）が永久にリークする恐れがあります。
  * **対応案**: クライアントから定期的なPingを送信するか、サーバ側からPingを送り、`conn.SetReadDeadline` を定期的に更新する仕組みを追加してください。
* **[hub.go: handleWS] メッセージサイズの制限 (ReadLimit) 不在**
  * **指摘**: Websocket接続の `ReadLimit` が設定されていません（デフォルトでは無制限リード）。ローカル通信限定ではあるものの、不意の巨大なJSONペイロードがクライアント側・あるいは悪意・バグによって送信された際に、メモリの過大消費やOOMを引き起こす懸念があります。防衛的プログラミングの観点から制限すべきです。
  * **対応案**: `upgrader` との通信後、`conn.SetReadLimit(maxMessageSize)` （例: 8KBなど）を設定してください。

### 2. 型と安全性機能設計 (Types & Code Quality)
* **[protocol.go: EncodePaneData] PaneIDの切り詰め時の衝突リスク**
  * **指摘**: `len(paneID) > maxPaneIDLen (255)` の場合に文字列を自動で切り詰めていますが、これによって異なるPaneID同士が同一の切り詰め後IDになってしまう（衝突する）リスクがあり、予期せぬデータ混入を招く可能性があります。
  * **対応案**: そもそもアプリケーションの仕様上 255 byte を超えるPaneIDが発行されないのであれば、現状の `slog.Debug` ではなく `slog.Warn` またはエラーを明示的に返す設計に格上げしたほうが安全です。
* **[recovery.go: runRecoveryLoop] タイマードレインへの仕様変更留意**
  * **指摘**: `if !restartTimer.Stop() { <-restartTimer.C }` は Go 1.22 以前での標準的なタイマードレイン手法ですが、Go 1.23 以降では仕様変更によりドレイン自体が不要となり、かえって誤動作やパニックを引き起こしにくく改善されています。現行コードのままでもこのコンテキストでは安全ですが、今後のバージョン更新時に簡略化できるポイントとして留意してください。

### 3. テストカバレッジ・品質 (Tests)
* **[hub_test.go: TestBroadcastPaneDataWriteError] 切断のシミュレーション方法**
  * **指摘**: テスト内で `conn.Close()` を使用してエラーを引き起こしていますが、これはWebSocketプロトコル上正常なCloseフレームを送信するため、綺麗なクローズとして扱われます。アブダプショナルなTCP切断を再現できていません。
  * **対応案**: `conn.UnderlyingConn().Close()` を使用して即座にTCPソケットを強制切断するテストを追加すると、先述の `Unexpected Close Error` のハンドリングカバレッジが向上します。

### 4. コメント・保守性 (Comments/Simplify)
* **強み (Strengths)**:
  * ロックの獲得順序 (`mu -> writeMu`) が `hub.go` に明確にコメントされており、デッドロック防止に対する設計意図が非常に高いレベルで表現されています。
  * `recovery.go` の指数バックオフリトライの意図（オーバーフローやCPUスピン回避）の記録、またテストケースに並行・非同期レースコンディションを加味した `atomic.Int32` や待機機構の採用は実用的で非常に高品質です。

---

## 📋 タスクと並列作業への割り当て計画

指摘事項を複数のサブエージェントや作業者が同時に対処できるよう、競合のおそれがないタスク分割を行いました。以下の表を元に改修を進めてください。

| タスクID | 修正対象ファイル (`myT-x/internal/`) | 対応内容概要 | 並列作業 | 競合・依存リスク |
| :--- | :--- | :--- | :---: | :--- |
| **Task 1** | `wsserver/hub.go`,<br>`wsserver/hub_test.go` | `SetReadDeadline` および `PingHandler/PongHandler` を用いた死活監視機能の追加。 | 🟢 可能 | `handleWS` 全体の監視ループへの修正のため、Task 2と同ファイルだが機能的に独立している。競合修正時のマージ対応のみ必要。 |
| **Task 2** | `wsserver/hub.go` | `handleWS` での `conn.SetReadLimit(maxSize)` 呼び出し追加。 | 🟢 可能 | Task 1と近い行（初期化部分）になるが数行の追加の範囲にとどまる。 |
| **Task 3** | `wsserver/protocol.go` | `EncodePaneData` において `paneID` が255バイト以上だった場合のエラー格上げ、もしくは `slog.Warn` への変更。 | 🟢 可能 | 他のモジュールから完全に切り離されたファイルのため、別エージェントで完全に並行処理可能。 |
| **Task 4** | `wsserver/hub_test.go` | `conn.UnderlyingConn().Close()` による強制的TCP切断（アブダプトクローズ）のテストケースを追加。 | 🟢 可能 | テストメソッドの新規追加にとどまるため、並行しての実装に全く問題なし。 |

* **推奨される適用フロー**:
  1. 並列実行： Task 3 は独立性が高いため、別プロセスでの即時修正が可能です。
  2. 並列実行： Task 1, 2, 4 は同じ `wsserver` パッケージとなりますが、それぞれ実装領域が異なるため、個別コミットとしての並行作業を安全に実施できます。
