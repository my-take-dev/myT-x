# PR Review Summary — 2026-02-22 16:11 (v2: 本番コード突合版)

> **v2 差分**: 本番コードを全ファイル読み込み、周辺の呼び出しコンテキスト・ロック粒度・影響範囲を確認して再レビュー実施。
> 前回レビューの一部指摘を昇格・降格・取り消し・新規追加。

## レビュー対象

`D:\myT-x\dev-myT-x\review\temp` 配下の diff ファイル 38 件を、以下 6 カテゴリに分類してレビューを実施。

| # | カテゴリ | 対象ファイル数 |
|---|---------|-------------|
| A | バックエンド – DevPanel API (Working Diff 新機能) | 4 |
| B | バックエンド – セッションログ (ping+fetch モデル、Seq 導入) | 7 |
| C | バックエンド – イベント・ライフサイクル・PaneAPI | 5 |
| D | バックエンド – tmux (ウィンドウ管理、テスト強化) | 10 |
| E | フロントエンド – Viewer / ErrorLog / Store / Hook | 12 |
| F | Wails バインディング (自動生成) | 3 |

---

## Critical Issues (3 件)

### CRIT-01: `buildUntrackedFileDiffsWithBudget` — WalkDir 内のバジェットガード条件バグ
- **ファイル**: `app_devpanel_api.go` (line 687)
- **本番コード確認**: line 687 `if remainingBudget >= 0 && remainingBudget <= 0` は `remainingBudget == 0` と等価。
- **呼び出しコンテキスト**: `DevPanelWorkingDiff()` (line 564) で `remainingBudget := devPanelMaxDiffSize - consumedSize` として渡される。この呼び出し元では `remainingBudget <= 0` を先にチェックして `break` するため、`buildUntrackedFileDiffsWithBudget` に渡される時点では `remainingBudget > 0` が保証されている。
- **WalkDir 内のフロー**: line 705 `if remainingBudget >= 0 && len(entry.Diff) > remainingBudget` でバジェット超過をチェックし `budgetExceeded = true` で終了する。line 710-711 で `remainingBudget -= len(entry.Diff)` する。問題は:
  1. `entry.Diff` のサイズが `remainingBudget` **以下**（line 705 をパスする）
  2. 減算後に `remainingBudget` が **正確にゼロ** → line 687 で `SkipAll`（正常）
  3. 減算後に `remainingBudget` が **負の値** → line 687 の `>= 0 && <= 0` が false → **次のファイルも処理される**
- **影響**: `entry.Diff` のサイズが `remainingBudget` とちょうど等しい場合は問題ないが、`remainingBudget` が 1 で `entry.Diff` が 1 バイトの場合にゼロになり、次のファイルで初めて line 687 が true になる。実質的に 1 ファイル分余計に処理される。大きな `entry.Diff`（例: 99KB）と小さな `remainingBudget`（例: 100 bytes）の場合は line 705 でガードされるため、深刻な超過ではない。
- **修正案**:
```go
// line 687: 修正前
if remainingBudget >= 0 && remainingBudget <= 0 {
// line 687: 修正後
if remainingBudget >= 0 && remainingBudget <= 0 { // ← ここだけでは不十分
// ↓ 正しくは:
if remainingBudget <= 0 {
```
ただし `remainingBudget` の初期値 `-1` は「無制限」を意味する（line 640 `buildUntrackedFileDiffs` から `-1` で呼ばれる）。`-1` の場合もここに到達するため、正しい修正は：
```go
if remainingBudget >= 0 && remainingBudget <= 0 {
// ↓
if remainingBudget == 0 {
```
これで `-1`（無制限モード）では false、`0`（予算消費完了）では true になる。
- **重要度**: 実害は軽微だが論理バグ。修正推奨。

### CRIT-02: `app_events.go` — UTF-8 文字化けコメント（CLAUDE.md 違反）
- **ファイル**: `app_events.go` (本番コード line 134, 140, 143, 153, 219, 222)
- **本番コード確認**: 実際にファイルを読むと以下の文字化け箇所が残存：
  - line 134: `窶・retained` → `— retained`
  - line 140: `窶・no policy` → `— no policy`
  - line 143: `窶・do not modify at runtime.` → `— do not modify at runtime.`
  - line 153: `迴ｾ蝨ｨ縺ｮ繧｢繝ｼ繧ｭ繝・け繝√Ε縺ｯ 1 繧ｻ繝・す繝ｧ繝ｳ = 1 繧ｦ繧｣繝ｳ繝峨え讒区・...` → 正しい日本語コメントに復元
  - line 219: `竕､ outputFlushInterval` → `≤ outputFlushInterval`
  - line 222: `窶・invisible` → `— invisible`
- **影響**: コード動作には影響しないが、CLAUDE.md の「全てUTF8でBOM無しとする」規約に違反。可読性が完全に失われた日本語コメントが複数行残存。
- **周辺影響**: `app_lifecycle.go` にも同様の箇所がないか確認 → line 277 `[SHIM]` は正常日本語、問題なし。`command_router_handlers_window.go` も確認 → line 227, 234, 240, 247-250 の日本語コメントは正常。文字化けは `app_events.go` のみに限局。

### CRIT-03: `errorLogStore.ts` — `setEntries` 初回ロード時に全エントリを既読扱いにする設計判断の未文書化
- **ファイル**: `errorLogStore.ts` (line 56-58)
- **本番コード確認**: `if (state.entries.length === 0 && state.lastReadSeq === 0 && maxNewSeq > 0)` で初回ロード時に `lastReadSeq = maxNewSeq` としている。
- **呼び出しコンテキスト**: `useBackendSync.ts` line 519 で `fetchErrorLog()` が mount 時に呼ばれ、`setEntries(result ?? [])` を実行。初回は `state.entries.length === 0` かつ `state.lastReadSeq === 0` なのでこの条件にマッチ。
- **影響**: 起動前に発生した全エラーが **未読バッジなし** で表示される。これが意図的な設計判断であればコメントで理由を明記すべき。
- **`ErrorLogView.tsx` との関連**: line 13-15 で `useEffect(() => { markAllRead(); }, [entries, markAllRead])` — ビューが開いているときは新しいエントリも即座に既読化される。これは `errorLogStore` の `lastReadSeq` を更新する (`markAllRead`, line 68-71)。
- **設計意図の推測**: アプリ起動時の「以前のセッションの残りログ」をバッジ表示しないようにする設計は合理的。ただしコメントに「起動前の既存ログは既読扱い: ユーザーが未確認でも新規エラーのみ通知する方針」と明記すべき。
- **修正案**: コメント追加のみで動作変更不要。

---

## Important Issues (14 件)

### IMP-01: `buildUntrackedFileDiffSingle` — 冗長な `os.Lstat` 呼び出し
- **ファイル**: `app_devpanel_api.go` (line 752-767)
- **本番コード確認**: `filepath.EvalSymlinks(absPath)` (line 742) が成功した時点でパスは実在し、シンボリンクは解決済み。その後 `os.Lstat(absPath)` (line 752) で再度ファイルをチェック。`EvalSymlinks` が成功すればファイルは存在するため、`Lstat` は冗長。
- **ただし**: `EvalSymlinks` はシンボリンクを **解決** するが、`Lstat` はシンボリンク **そのもの** の情報を返す。line 757 の `lstatInfo.Mode()&os.ModeSymlink != 0` チェックは、`absPath` 自身がシンボリンクかを判定するもので、`EvalSymlinks` では代替できない（`EvalSymlinks` はエラーなしで解決するだけ）。
- **`cachedInfo` との関係**: 呼び出し元 `buildUntrackedFileDiffsWithBudget` (line 697) で `d.Info()` が `WalkDir` のエントリから取得される。Go の `filepath.WalkDir` は `DirEntry.Info()` で `Lstat` 相当の情報を返す（ドキュメント: "Info returns the FileInfo for the file or subdirectory described by the entry"）。したがって `cachedInfo` は **Lstat 由来** であり `lstatInfo` と同じセマンティクス。
- **結論**: 前回レビューの CRIT-02 (cachedInfo セマンティクス不整合) は **取り消し**。`cachedInfo` と `lstatInfo` は同じ Lstat 由来であり不整合はない。ただし `cachedInfo` 提供時でも `os.Lstat` が冗長に呼ばれる（シンボリンクチェック目的）。
- **修正案**: `cachedInfo` が提供された場合、そのモードビットでシンボリンクチェックを行えば `os.Lstat` を省略可能。ただし、TOCTOU 防御として意図的に再チェックしている可能性もあるため、低優先度。

### IMP-02: `DevPanelWorkingDiff` — `isFreshRepo` 判定で git 以外のエラーも fresh repo 扱い
- **ファイル**: `app_devpanel_api.go` (line 515-516)
- **本番コード確認**: `_, headErr := gitpkg.RunGitCLIPublic(workDir, []string{"rev-parse", "--verify", "HEAD"})` → `isFreshRepo := headErr != nil`
- **本番での影響**: `isFreshRepo = true` の場合、`diff --cached` が実行される (line 523-531)。git バイナリ不在や権限エラー時に `diff --cached` も失敗するが、line 528-530 で `diffLoadIncomplete = true` としてフォールバックし、`truncated = true` でマーク。
- **結論**: エラー種別を区別しないが、フォールバックパスが安全。`slog.Info` (line 521) でエラー内容が記録されるため診断は可能。低優先度。

### IMP-03: `initSessionLog` → `cleanupOldSessionLogs` のロック粒度
- **ファイル**: `app_session_log.go` (line 43-50)
- **本番コード確認**: `initSessionLog()` は line 43-46 で `Lock()` → `sessionLogFile, sessionLogPath` を設定 → `Unlock()`。line 49 で `cleanupOldSessionLogs()` を呼び、その中で line 55 `RLock()` → `currentPath` を読む → `RUnlock()`。
- **呼び出しコンテキスト**: `app_lifecycle.go` line 149 `a.initSessionLog()` は `startup()` 内で呼ばれる。この時点では `slog.SetDefault(slog.New(teeHandler))` (line 160) はまだ実行されておらず、TeeHandler → `writeSessionLogEntry` の再帰呼び出しは発生しない。
- **結論**: startup 時限定の呼び出しであり、並行アクセスのリスクはない。前回指摘通り「startup 時のみ呼ばれる前提」のコメント追加を推奨。

### IMP-04: `cleanupOldSessionLogs` — PID 部分の辞書順ソート
- **ファイル**: `app_session_log.go` (line 83-86)
- **本番コード確認**: コメント (line 83-86) に「approximate age ordering」と明記されており、意図的な設計。
- **結論**: 指摘のみ。修正不要。

### IMP-05: `writeSessionLogEntry` — `syncFile.Sync()` 時の OS 固有エラー
- **ファイル**: `app_session_log.go` (line 165-173)
- **本番コード確認**: `errors.Is(syncErr, os.ErrClosed) || errors.Is(syncErr, syscall.EINVAL)` でガード。
- **`closeSessionLog()` との関連**: line 200-204 で `Lock()` → `sessionLogFile.Close()` → `sessionLogFile = nil` → `Unlock()`。`writeSessionLogEntry` の line 136 で `syncFile = a.sessionLogFile` を Lock 内でキャプチャ。`closeSessionLog` が先に `Close()` を呼ぶと、`syncFile` は Close 済みの `*os.File` を指す。
- **Linux の場合**: `os.ErrClosed` は Go ランタイムが付与。`syscall.EINVAL` は Windows 固有。Linux では `EBADF` が返る可能性があるが、Go の `file_posix.go` は `os.ErrClosed` にラップするため `errors.Is(syncErr, os.ErrClosed)` でカバーされる。
- **結論**: Windows + Go ランタイムの組み合わせで `syscall.EINVAL` を明示的にガードしているのは適切。`syscall.EBADF` の追加は不要（Go がラップ済み）。前回指摘を **降格**（修正不要）。

### IMP-06: `sessionlog/handler.go` — `WithGroup("")` の receiver 返却
- **ファイル**: `internal/sessionlog/handler.go` (line 99-101)
- **本番コード確認**: `if name == "" { return h }` — slog.Handler 仕様準拠。`WithAttrs` (line 85-87) も `len(attrs) == 0` で同様のショートサーキット。
- **影響**: パフォーマンス最適化 + 仕様準拠。問題なし。

### IMP-07: `ErrorLogView.tsx` — `markAllRead()` が `entries` 変更のたびに呼ばれる
- **ファイル**: `ErrorLogView.tsx` (line 13-15)
- **本番コード確認**: `useEffect(() => { markAllRead(); }, [entries, markAllRead])` — `entries` が依存配列に含まれているため、新しいエントリが到着するたびに `markAllRead` が呼ばれる。`errorLogStore.ts` の `markAllRead` (line 68-71) は `lastReadSeq = entries.at(-1)?.seq` を設定。
- **影響**: ErrorLogView が **開いている間** は全てのエントリが即座に既読化される。これは意図的な動作（ビューを見ているなら既読）。ただし `markAllRead` は zustand の `set` を呼ぶため、`entries` が変わるたびに **2回のストア更新** が走る（`setEntries` + `markAllRead`）。
- **修正案**: `markAllRead` を `setEntries` 内に統合する案もあるが、関心の分離の観点から現在の設計は妥当。パフォーマンス影響は zustand の batching で吸収される。低優先度。

### IMP-08: `useBackendSync.ts` — debounce timer の `!= null` ガード
- **ファイル**: `useBackendSync.ts` (line 507)
- **本番コード確認**: `if (errorLogDebounceTimer != null)` — TypeScript では `null` と `undefined` の両方を `!= null` でガードできる。`clearTimeout(null)` は `clearTimeout(0)` と等価で無害だが、明示的なガードは可読性に寄与。
- **影響**: 問題なし。

### IMP-09: `errorLogStore.ts` — backend restart 時の seq リグレッション検出
- **ファイル**: `errorLogStore.ts` (line 51-54)
- **本番コード確認**: `if (maxNewSeq > 0 && maxNewSeq < lastReadSeq)` で `lastReadSeq = 0` にリセット。
- **`GetSessionErrorLog()` の本番動作**: バックエンドの `GetSessionErrorLog()` (app_session_log.go line 211-221) はリングバッファの `snapshot()` を返す。バックエンド再起動時は新プロセスが起動し、旧プロセスのバッファは存在しない。Wails アプリは単一プロセスなので、バックエンド再起動 = アプリ再起動 = フロントエンドもリセット。
- **結論**: Wails アーキテクチャでは「バックエンドのみ再起動」は発生しない。この seq リグレッション検出は **防御的コーディング** として有用だが、実行時に到達する可能性は極めて低い。問題なし。

### IMP-10: `viewerRegistry.ts` — `globalThis` への副作用
- **ファイル**: `viewerRegistry.ts` (line 13-27)
- **本番コード確認**: `REGISTRY_KEY = "__mytx_view_registry__"` を `globalThis` に書き込み。`import.meta.hot.dispose` で HMR 時にクリア。
- **Vite HMR での動作**: 各ビューモジュール（`file-tree/index.ts`, `git-graph/index.ts`, `error-log/index.ts`, `diff-view/index.ts`）が再評価時に `registerView()` を呼ぶ。`dispose` でクリア → 再登録の流れは正しい。
- **`registerView` の重複対策**: line 45-49 で `findIndex` + 上書き。HMR で同じ ID が再登録される場合はインプレース更新。
- **結論**: Wails SPA 環境では問題なし。テスト環境（jsdom等）では `globalThis` がテスト間で共有される可能性があるが、現時点でのテスト方針（Go テスト中心）では影響なし。

### IMP-11: `injectTestWindow` — 内部ロック直接操作
- **ファイル**: テストヘルパー（差分内）
- **本番コード確認**: `session_manager_windows.go` で `AddWindow` が削除されているため（line 3-12 のコメント）、マルチウィンドウ状態をテストするには内部操作が唯一の手段。
- **結論**: 設計上やむを得ない。コメントで注意書きが適切に記載されている。

### IMP-12: `handleNewWindow` — `GetSession` 失敗時のロールバック
- **ファイル**: `command_router_handlers_window.go` (line 307-309)
- **本番コード確認**: `newSessionSnap, snapOk := r.sessions.GetSession(newSessionName); if !snapOk { return rollbackSession(...) }` — `GetSession` は deep clone を返す。`CreateSession` (line 269) 成功後、`copySessionFlags` (line 294) 成功後に呼ばれる。`GetSession` が `false` を返すケースは、別のゴルーチンが同名セッションを削除した場合のみ。
- **結論**: startup 時以外では理論上ありえるが、実運用上はほぼ到達不能。ロールバックは安全側に倒す変更として適切。

### IMP-13: `removeWindowAtIndexLocked` — `window != nil && len(window.Panes) > 0` の条件追加
- **ファイル**: `session_manager_windows.go` (line 114)
- **本番コード確認**: 変更前は `if window != nil` のみ。変更後は `if window != nil && len(window.Panes) > 0` を追加。
- **影響**: `window.Panes` が空スライス（`[]`) の場合、`make([]*TmuxPane, 0)` の再割り当てを回避。`copy` は空スライスでは no-op だが、`make` のアロケーションを省略できる。
- **結論**: 防御的最適化。問題なし。

### IMP-14 (新規): `useErrorLog.ts` — `bodyRef.current` がオートスクロールで使用されるが `registerBodyElement` 経由で設定
- **ファイル**: `useErrorLog.ts` (line 20-23, 26-34)
- **本番コード確認**: `bodyRef` は `useRef<HTMLDivElement | null>(null)` で初期化。`registerBodyElement` (line 21-23) は `bodyRef.current = el` を設定する `useCallback([], [])`。オートスクロール (line 26-33) は `bodyRef.current` を参照。
- **影響**: `registerBodyElement` は `ErrorLogView.tsx` の `bodyRefCallback` (line 22-77) から呼ばれる。`bodyRefCallback` はコールバック ref として使われるため、React がコミット時に呼ぶ。`useEffect(() => { ... }, [entries.length])` (line 26-34) のオートスクロールは、`entries.length` 変更時に `bodyRef.current` を参照するが、初回レンダリング時にはコールバック ref がまだ呼ばれていない可能性がある（useEffect は commit 後に実行されるが、callback ref も commit 時に呼ばれるため通常は問題ない）。
- **結論**: React のライフサイクル上、callback ref の呼び出しは useEffect より先に実行されるため、`bodyRef.current` は `useEffect` 実行時には設定済み。問題なし。

---

## Suggestions (16 件)

### SUG-01: `bytes.IndexByte` への変更
- **ファイル**: `app_devpanel_api.go` (line 785)
- **本番コード確認**: `bytes.IndexByte(data[:probeSize], 0) >= 0` — `bytes.ContainsRune` からの変更。`IndexByte` は SIMD 最適化された実装を持ち、パフォーマンス改善として適切。

### SUG-02: `commitHash` への `--` 終端子追加
- **ファイル**: `app_devpanel_api.go` (line 478)
- **本番コード確認**: `git diff-tree --root -p commitHash --` — 引数のパス解釈防止。`ValidateCommitish` で入力検証済みだが、defense-in-depth として良い変更。

### SUG-03: ログプレフィックスの統一
- **ファイル**: 複数ファイル
- **本番コード確認**: 統一状況：
  - `[DEVPANEL]` ← `[DEBUG-DEVPANEL]` ✅ 統一済み
  - `[EVENT]` ← `[DEBUG-EVENT]` ✅ 統一済み
  - `[SHIM]` ← `[DEBUG-SHIM]` ⚠️ 一部変更 (`app_lifecycle.go` line 277)。ただし line 247 は `[shim]` (小文字)。統一が不完全。
  - `[WINDOW]` ← `[DEBUG-WINDOW]` ⚠️ 一部変更 (`command_router_handlers_window.go` line 286, 329)。ただし line 263, 301, 322 は `[DEBUG-WINDOW]` のまま。
  - `[IPC]` ← `[DEBUG-IPC]` ⚠️ `app_lifecycle.go` line 465 のみ変更。
  - `[PANE]` ← `[DEBUG-PANE]` ✅ 統一済み
  - `[DEBUG-HOTKEY]` ← 未変更 (`app_lifecycle.go` line 439, 449, 492)
  - `[DEBUG-WS]` ← 未変更 (`app.go` line 143, `useBackendSync.ts` line 153)
  - `[DEBUG-CONFIG]` ← 未変更 (`app_lifecycle.go` line 186)
- **結論**: 今回の PR で部分的に統一されたが、まだ `[DEBUG-*]` が残存する箇所がある。CLAUDE.md の「デバッグ用としてログ名を統一して削除しやすくしておく」に照らすと、`DEBUG-` プレフィックスは削除しやすくするためのマーカーなので、維持する方針でもよい。**ただし同一ファイル内で `[shim]` (小文字) と `[SHIM]` (大文字) が混在するのは統一すべき。**

### SUG-04: `sessionLogRingBuffer` — `cap` → `bufCap` リネーム
- **ファイル**: `app_session_log_types.go` (line 43)
- **本番コード確認**: Go 組み込み関数 `cap` とのシャドウイング回避。良い変更。

### SUG-05: `sessionLogRingBuffer.push` — `bufCap == 0` ガード
- **ファイル**: `app_session_log_types.go` (line 44-46)
- **本番コード確認**: `newSessionLogRingBuffer` (line 32-33) で `capacity < 1` を 1 にクランプ。`bufCap == 0` は到達不能だが防御的。

### SUG-06: `snapshot()` — `min()` ビルトイン使用
- **ファイル**: `app_session_log_types.go` (line 71)
- **本番コード確認**: `bufCap-rb.head` と `rb.count` の `min`。Go 1.21+ ビルトイン。CLAUDE.md は Go 1.26 を指定しているため使用可能。

### SUG-07: `TeeHandler` — `WithAttrs([])/WithGroup("")` のショートサーキット
- **ファイル**: `internal/sessionlog/handler.go` (line 85-87, 100-101)
- **本番コード確認**: slog.Handler 仕様準拠。良い変更。

### SUG-08: `ViewerSystem.tsx` — ショートカットマップの `useMemo` 化
- **ファイル**: `ViewerSystem.tsx` (本番コード line 41-50)
- **本番コード確認**: `useMemo(() => { ... }, [])` — 空 deps で once 生成。`getRegisteredViews()` は非リアクティブなので正しい。新規ビュー追加時にコードの変更不要になる。良いリファクタリング。

### SUG-09: `ActivityStrip.tsx` — `position` による top/bottom 分離
- **ファイル**: `ActivityStrip.tsx`
- **本番コード確認**: `topViews.map(renderViewButton)` + spacer + `bottomViews.map(renderViewButton)`。CSS の `viewer-strip-spacer` (viewer.css line 10-12) は `flex: 1; min-height: 0` でスペーサーとして機能。
- **関連**: `error-log/index.ts` で `position: "bottom"` が設定されている。

### SUG-10: `stubRuntimeEventsEmit` によるテストの DRY 化
- **ファイル**: `app_session_log_test.go`
- 良い変更。

### SUG-11: `testutil.Ptr` の `//go:fix inline` ディレクティブ
- **ファイル**: `internal/testutil/helpers.go`
- Go 1.24+ の `go fix` 対応。将来的なヘルパー廃止を容易にする。

### SUG-12: `boolPtr` → `testutil.Ptr` 統一
- **ファイル**: 複数テストファイル
- 良いリファクタリング。

### SUG-13: `WorkingDiffStatus` の type alias 採用
- **ファイル**: `app_devpanel_types.go` (line 48)
- **本番コード確認**: `type WorkingDiffStatus = string` — Wails バインディング生成との互換性のためのトレードオフ。コメントに明記されている。

### SUG-14: `normalizeEntries` のパイプライン化
- **ファイル**: `errorLogStore.ts` (line 26-31)
- `filter → sort → slice(-MAX_ENTRIES)` の明快なパイプライン。良い変更。

### SUG-15 (新規): `DevPanelWorkingDiff` — `output` が空の場合の最適化
- **ファイル**: `app_devpanel_api.go` (line 543-555)
- **本番コード確認**: `raw := string(output)` は `output` が空でも `parseWorkingDiff(raw)` を呼ぶ。`parseWorkingDiff` (line 847) は `strings.TrimSpace(raw) == ""` で nil を返す。
- **修正案**: `if len(output) == 0` で早期リターンすれば `string(output)` のアロケーションを回避できる。低優先度。

### SUG-16 (新規): `DevPanelWorkingDiff` — fresh repo での `diff --cached` 失敗時に untracked のみで継続する設計の明示
- **ファイル**: `app_devpanel_api.go` (line 527-531)
- **本番コード確認**: `diffLoadIncomplete = true` として `truncated` フラグに反映し、untracked ファイルの処理は継続。
- **結論**: 設計として合理的だが、「staged diff が取得できなかった旨」がフロントエンドに伝わらない（`truncated` は汎用フラグ）。ユーザビリティ改善として `WorkingDiffResult` にエラーメッセージフィールドを追加することも検討可能。低優先度。

---

## Strengths (良い点)

1. **ping + fetch モデル (A-0)**: `writeSessionLogEntry` でのペイロード排除、`emitRuntimeEvent("app:error-log-updated", nil)` によるデータロス防止。本番コードの `writeSessionLogEntry` (line 104-193) と `GetSessionErrorLog` (line 211-221) を確認し、設計の一貫性を確認。
2. **Seq による安定キー**: `uint64` の `sessionLogSeq` (app.go line 110) が `writeSessionLogEntry` (line 128-129) でインクリメントされ、`SessionLogEntry.Seq` に設定。フロントエンドの `key={entry.seq}` (`ErrorLogView.tsx` line 156) で React の再描画安定性向上。
3. **セキュリティ**: `buildUntrackedFileDiffSingle` の二重パスバリデーション（line 729-750: lexical + symlink 解決後）。`resolveAndValidatePath` (line 79-108) との一貫性を確認。
4. **テストカバレッジ**: フィールド数ガード、テーブル駆動テスト、エッジケース網羅。
5. **リングバッファの堅牢化**: `newSessionLogRingBuffer` (line 30-39) のクランプ、`push` のゼロガード (line 44-46)、`snapshot` の min ビルトイン使用 (line 71)。
6. **TeeHandler の改善**: callback panic 回復 (line 64-74)、base error 伝搬 (line 79)、空入力最適化 (line 85, 100)。
7. **1-window モデルの設計文書**: `session_manager_windows.go` line 3-12、`command_router_handlers_window.go` line 395-399 のコメントが将来の拡張方針を明確化。
8. **`rollbackSession` パターン**: `handleNewWindow` (line 284-291) のロールバック関数が cleanup を保証。`RemoveSession` 呼び出しによるセッション状態クリーンアップが完全。
9. **errorLogStore の eviction 設計**: `normalizeEntries` での `slice(-MAX_ENTRIES)` + `unreadCount` の再計算が eviction 後も一貫性を保つ設計。

---

## Recommended Action

| 優先度 | タスクID | 内容 | 工数見積 |
|-------|---------|-----|---------|
| 🔴 最優先 | CRIT-01 | `buildUntrackedFileDiffsWithBudget` line 687 の条件修正 | 5分 |
| 🔴 最優先 | CRIT-02 | `app_events.go` の文字化けコメント復元 | 15分 |
| 🟡 推奨 | CRIT-03 | `errorLogStore.ts` の初回既読判定コメント追加 | 5分 |
| 🟡 推奨 | SUG-03 | ログプレフィックスの混在修正 (`[shim]`/`[SHIM]`, `[DEBUG-WINDOW]`/`[WINDOW]`) | 10分 |
| 🔵 低 | IMP-01〜IMP-14 | コメント補強、防御的コーディング | 各5分 |

---

## 並列作業可否テーブル

| タスクID | 対象ファイル | 修正内容 | 並列作業 | 依存先 | 備考 |
|---------|------------|---------|---------|-------|-----|
| CRIT-01 | `app_devpanel_api.go` | line 687 条件修正 | ◯ | なし | 1行修正。他箇所に影響なし |
| CRIT-02 | `app_events.go` | 文字化けコメント復元 | ◯ | なし | コメントのみ。コードロジック変更なし |
| CRIT-03 | `errorLogStore.ts` | 設計意図コメント追加 | ◯ | なし | フロントエンドのみ |
| IMP-01 | `app_devpanel_api.go` | 冗長 Lstat の最適化 | △ | CRIT-01 | 同一ファイル。CRIT-01と同時修正推奨 |
| IMP-02 | `app_devpanel_api.go` | isFreshRepo 改善 | △ | CRIT-01 | 同一ファイルだが低優先度 |
| IMP-03 | `app_session_log.go` | startup 前提コメント追加 | ◯ | なし | コメントのみ |
| IMP-07 | `ErrorLogView.tsx` | markAllRead の二重更新確認 | ◯ | なし | 確認のみ。コード変更不要 |
| SUG-03 | 複数ファイル | ログプレフィックス統一 | △ | CRIT-02 | `app_events.go` と重複。CRIT-02完了後推奨 |

### 並列作業グルーピング（推奨）

| グループ | タスク | 担当範囲 | 理由 |
|---------|-------|---------|-----|
| **G1: DevPanel API** | CRIT-01, IMP-01, IMP-02 | `app_devpanel_api.go` | 同一ファイルへの修正を集約 |
| **G2: イベント文字化け + ログ統一** | CRIT-02, SUG-03 | `app_events.go` + 関連ファイル | 文字化け修正とプレフィックス統一を一括 |
| **G3: セッションログ** | IMP-03 | `app_session_log.go` | コメント追加のみ |
| **G4: フロントエンド** | CRIT-03, IMP-07 | `errorLogStore.ts`, `ErrorLogView.tsx` | フロントエンド関連を集約 |

> **注意**: G1〜G4 は全て **完全並列作業可能** です。ファイル間の依存はありません。
> SUG-03 は複数ファイルにまたがるため、G2 に含める場合は他グループの対象ファイルとの競合に注意してください。

---

## 前回 (v1) からの変更点

| 前回 ID | 変更内容 | 理由 |
|--------|---------|------|
| CRIT-02 (前回) | **取り消し** | 本番コード確認で `cachedInfo` は `d.Info()` (= Lstat 由来) であり不整合なし |
| CRIT-04 (前回) | → **CRIT-03 (今回)** に改番 | 内容は維持。コメント追加を推奨に変更 |
| IMP-05 (前回) | **降格 → 修正不要** | Go ランタイムが `EBADF` を `os.ErrClosed` にラップするため追加ガード不要 |
| IMP-13 (新規) | 追加 | `removeWindowAtIndexLocked` の条件追加を本番コードで確認 |
| IMP-14 (新規) | 追加 | `useErrorLog.ts` での `bodyRef` ライフサイクル確認 |
| SUG-15 (新規) | 追加 | `DevPanelWorkingDiff` の空出力最適化 |
| SUG-16 (新規) | 追加 | fresh repo でのフォールバック設計の明示 |
