# PR Review Summary (2026-02-22 18:53:09)

本コードレビュー結果は `D:\myT-x\dev-myT-x\review\temp` にある多量のファイルを一括レビューし、並列作業が可能になるようカテゴリ別に分析・評価・タスク分類したものです。バックエンド（通信・Git・ファイル監視等）および関連するフロントエンド（React/Wails同期状態）などの影響範囲や周辺仕様も含め、広範かつ詳細に検証しています。

---

## 🛑 Critical Issues (修正必須)

### 1-1. リトライタイマーの競合・多重リクエスト誘発のリスク [フロントエンド]
_`myT-x/frontend/src/hooks/useBackendSync.ts` : 476行目付近_
- **内容:** バックエンドから `app:session-log-updated` (Ping) を受信する際、`fetchErrorLog` によってエラーログを一括取得（Fetch）するようにリファクタリングされています。
しかしながら、「バックエンドのフェッチに失敗した際のリトライタイマー (`errorLogRetryTimer`)」が、新しいパルス（イベント）が飛んできた時にキャンセル（`clearTimeout(errorLogRetryTimer)`）されていません。
- **影響・周辺の影響:** イベントが連続で発生しつつ、たまたまAPIの通信エラーが複数回挟まった場合、重複したリトライタイマーが多数生成されて多重リクエスト祭り（Fetch Spike）が起きる恐れがあります。デバウンスの `errorLogDebounceTimer` だけではなく、**既存のリトライタイマーも同時にクリア**してください。
- **修正案:** イベント受信(`onEvent("app:session-log-updated", ...)`)直後、デバウンスタイマーをクリアする箇所で、同時に `errorLogRetryTimer` も `clearTimeout` と `null` 設定を行ってください。

### 1-2. Wails ランタイムイベントの同期競合（Mutex Lockとの乖離）[バックエンド]
_`myT-x/app_session_log.go` : 100行目以降 および 188行目_
- **内容:** 今回の対応で Mutex取得中のファイルへの書き込みと `shouldEmit` フラグ算出を行った後、Mutex の範囲外で Sync および `emitRuntimeEvent` を行うなど、並行処理への最適化が行われています。ですが、「ファイルディスクリプタをキャプチャし、後でSync」するという仕様自体はロック外で `syncErr` とファイル消滅との競合が発生します。現状の `isExpectedCloseRace` は `syscall.EINVAL` に依存していますが、Linux/MacOSでは他のエラー形式が返ることがあるため可搬性が弱いです（`fsync`中のクローズ競合）。
- **影響:** OSの環境（特に本番が Windows 以外となった場合や Linux コンテナの場合）において競合時にランタイムPanicやエラーログの過剰なノイズを招く可能性があります。
- **修正案:** この設計アプローチ自体はパフォーマンス上正しいですが、OSごとの差異を吸収する `isClosedError(err)` ヘルパを利用するか、または Wails/app 終了フックを通じてファイルのクローズ前にはSync状態が確定するように LifeCycle をより綺麗に同期して確実にロック内でSyncするか処理順序を徹底してください。

---

## ⚠️ Important Issues (推奨修正事項)

### 2-1. `ls-files -z` 時のメモリ確保のスパイク性対応 [Git/DevPanel処理]
_`myT-x/app_devpanel_api.go` : 260行目付近 `collectUntrackedFiles`_
- **内容:** `git ls-files --others -z` コマンドの結果を `io.ReadAll` 相応（GitCLIラッパー経由）で受け、更に `strings.Split("\x00")` しています。
- **指摘事項・影響:** `untracked` なファイルが万単位で存在した瞬間（例：node_modules が .gitignore から漏れ、誤って一時展開された時）、パース・Split処理により一気に数百MBのピークメモリを消費しGCを圧迫します。`devPanelMaxUntrackedFilePaths` への上限保護はされていますが、**Split前に文字列が一気にアロケーションされる**という問題は防げていません。
- **一括修正の方針:** 効率的にパースするために、`bytes.Split` にする、または `bytes.IndexByte` をループさせて必要上限（Max）に触れたら早期break（残りをパースしない）する形に最適化するとGoの処理上限に対して安全になります。

### 2-2. Symlinks再帰参照ループ時の防護不足とStatコストについて [Git/DevPanel処理]
_`myT-x/app_devpanel_api.go` : 304行目付近 `buildUntrackedFileDiffsWithBudget`_
- **内容:** `filepath.WalkDir` によるディレクトリ再帰を行い、Diffを作成しています。シンボリックリンク自身は除外（`ModeSymlink`判定）されていますが、`Walking`処理そのものが深い階層になったとき、多数の `os.Lstat` が連続して発動します。
- **指摘事項・影響:** パフォーマンス上のボトルネックになり得ます。また、Budgets の消費上限のガード `remainingBudget` の判定は各ファイルのDiff生成後になっています。ファイルの中身の生成時に`devPanelMaxUntrackedFileSize` までは読んでしまうため、合計予算をオーバーしたあとに「大きかった」と判明する無駄打ちの Read が起きます。
- **一括修正の方針:** `WalkDir`の `Path` ごとの Size (`info.Size()`) を Diff に変換する**前に**算出し、事前に `remainingBudget` と比較する軽量なチェックを入れる（Pre-Check機能）ことで、Diff生成処理ごとスキップできるようにしてください。

### 2-3. `useLayoutEffect` 内での無限ループ懸念 [フロントエンド表示]
_`myT-x/frontend/src/components/viewer/views/error-log/ErrorLogView.tsx`_
- **内容:** `entries` が更新されるたびに `markAllRead()` が呼ばれて既読フラグを外します。
- **影響:** 現在の `useErrorLogStore` は `markAllRead()` 内で `entries` オブジェクト自体の参照を変更しないため無限ループは起きませんが、ストア管理のアーキテクチャや配列ソート・sliceを微修正した際に無限再ループに陥る時限爆弾を含んでいます。
- **修正案:** API呼び出しで依存関係から `entries` 自身をWatchせず、「シーケンスIDの最新（`lastReadSeq`等）」だけを効果のトリガにさせるか、コンポーネントのマウント/アンマウントや可視状態(`IntersectionObserver` 等) の判定とセットにする方が安全です。

---

## 🛠 Suggestions (改善案)

- **S-1: Diff 出力のフロントエンド型定義の完全一致化** <br>
  `app_devpanel_api_test.go` における `countStructFields[WorkingDiffFile]` ガードは優れた戦略です！しかし `import.meta.env.DEV` による出力エラーのWarnなども多く、構造体の定義変化に対してフロント側との乖離を防ぐためにも、Protobufによる型定義か、あるいは `wailsjs/go/models.ts` を生成するフローを前提としてTS側で `models` から直接参照したほうがメンテ・コストが安全です。
- **S-2: `sessionlog/handler.go` における `Handle` のエラー伝搬** <br>
  エラーが常に上位に伝搬されるのは良い設計ですが、その過程でアプリケーション内部のロギングエラー（特にDisk Full時等）がコンソール標準エラー(`os.Stderr`)と混ざっています。本番のバイナリがどこを出力先にするかによってユーザの気付きが変わるため、通知（Toast警告等）のフック処理の拡充を推奨します。（今回一部Panicの通知は実装されているのでこの方向性を維持してください）

---

## 👍 Strengths (長所)

- **O(1) 同期処理の隔離とデバウンス設計** :  全体として、JSONLで直接シリアライズしつつメモリリングバッファと切り離して出力するアプローチ、フロント側が受動的に取得をデバウンスさせる「Ping + Fetch」化など、ハイパフォーマンスと過負荷保護をかなり重視した堅牢な設計へ昇華されています。特に `seq` の導入による単調増加アプローチへの転換とメモリリーク対策は素晴らしい出来です。
- **堅固な境界テスト** : `parseWorkingDiff_WindowsLineEndings` など、WindowsとUnix系での改行混在への防護など、プラットフォーム・アーキテクチャレベルでの単体テストが非常に充実しています。

---

## 📊 並列タスク割り当て/サブエージェント向け整理表

全体を複数サブエージェント（または複数人・並列タスク）に振り分けられるよう、競合リスクの有無とともに以下に分割定義しました。
作業の際は、それぞれの番号の範囲に集中すればGitでのMerge競合（コンフリクト）やロジック破壊を防止できます。

| タスク ID | 作業カテゴリ | 対象ファイル群（責務領域） | 並列性 (競合リスク) | 推奨作業概要 & CheckPoints |
|:---|:---|:---|:---|:---|
| **Task-A** | **DevPanel 最適化**<br>(Git/File I/O) | `app_devpanel_api.go` <br> `app_devpanel_api_test.go` <br> `app_devpanel_types.go` | **🔵 安全に並列可** | - メモリ枯渇対応のさらなる防護処理 (`bytes.Split` 等への変更。Issue 2-1)<br>- Diff生成処理の `WalkDir` 内部でのBudget軽量事前評価の導入 (Issue 2-2) |
| **Task-B** | **ErrorLog ストア・表示同期 UI**<br>(Frontend React/TS) | `useBackendSync.ts` <br> `ErrorLogView.tsx` <br> `errorLogStore.ts` | **🟡 中 (注意)** | - リトライタイマーの確実なクリアロジックを修正 (`errorLogRetryTimer` 落とし問題: Issue 1-1)<br>- `useLayoutEffect` における循環依存要素の見直し (Issue 2-3)<br>- ※ Task-CでバックエンドからのPingが正しく飛ぶかの確認と連動します。 |
| **Task-C** | **Session / Error Log Backend**<br>(Logger / Events) | `app_session_log.go` <br> `app_session_log_test.go` <br> `internal/sessionlog/*`<br>`app_events.go` | **🔵 安全に並列可** | - Mutex ロック範囲外の Sync 時の OS 差異吸収の実装（Issue 1-2 の `syscall.EINVAL` 以外の競合保護）|
| **Task-D** | **Tmux Window & Pane Logic**<br>(Terminal Core) | `internal/tmux/*` に関連する対象全ファイル | **🔵 安全に並列可** | 今回のメイン課題からはやや独立したロジックであり、ActiveWindow Transitions 系の動作確認と仕様強化を実施（現状Issueなし、コード品質維持確認のみの領域） |

### 🚀 Recommended Action
1. **Task-B (フロントエンドのリトライタイマー漏れ)** と **Task-A (Git周りのRead挙動・メモリ消費スパイクの改善)** をそれぞれ最優先で並行して修正着手してください。
2. 次に **Task-C** のバックエンドのSyncエラー制御処理をリファクタリングします。
3. 全ての修正が終わり次第、結合テストとして「Ping+Fetch」時に正常に過負荷なくログが受け取れるかの動作検証工程に統合してください。
