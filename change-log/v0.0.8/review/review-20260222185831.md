# PR Review Summary — 2026-02-22

> レビュー対象: コミット前差分 (44ファイル)  
> レビュー観点: code / errors / tests / comments / types / simplify / side-effects  
> レビュー方針: [review-pr-para.prompt.md](../.github/prompts/review-pr-para.prompt.md) 準拠

---

## 1. 変更概要

| カテゴリ | 主な変更内容 |
|---|---|
| **A. DevPanel WorkingDiff** | 新機能 `DevPanelWorkingDiff` — 未コミット差分（staged + unstaged + untracked）を取得するAPIを追加 |
| **B. SessionLog 刷新** | ping+fetch モデルへ変更 (`app:error-logged` → `app:session-log-updated`), Seq フィールド追加 |
| **C. ログプレフィックス統一** | `[DEBUG-*]` → `[*]` への全面リネーム |
| **D. エラー隠蔽の修正** | rollback失敗時のエラーラップ廃止 (`%w (rollback failed: %v)` → 元エラーのみ返却) |
| **E. TeeHandler 改善** | コールバック panic 回復, base エラー無視の廃止, WithAttrs/WithGroup の最適化 |
| **F. Tmux テスト追加** | `injectTestWindow` ヘルパー, window/paneのマルチウィンドウ境界テスト追加 |
| **G. フロントエンド改善** | ViewerRegistry HMR対応, diff-view新規追加, ActivityStrip のポジション対応 |
| **H. `session_manager_windows.go`** | `removeWindowAtIndexLocked` の `RemovedPanes` 生成を `append` に変更 (nil → 空スライス) |

---

## 2. Critical Issues (必ず修正) — 2件 (1件は確認により解消)

### CRIT-01: `sessionLogSeq` の初期化 — 確認済み、問題なし (本番コード確認)

**ファイル:** `app.go` L107 (本番コード確認済み)  
**深刻度:** 解消 (要確認から変更)  

```go
// app.go の App 構造体
sessionLogSeq uint64   // ゼロ値 = 0

// NewApp() での初期化
func NewApp() *App {
    return &App{
        paneFeedCh:        make(chan paneFeedItem, 4096),
        snapshotCache:     map[string]tmux.SessionSnapshot{},
        hotkeys:           hotkeys.NewManager(),
        paneStates:        panestate.NewManager(512 * 1024),
        sessionLogEntries: newSessionLogRingBuffer(sessionLogMaxEntries),
        // sessionLogSeq は明示的に初期化されていないがゼロ値=0 が期待値
    }
}
```

`sessionLogSeq` は `uint64` でゼロ値は `0` です。`writeSessionLogEntry` では:
```go
a.sessionLogSeq++      // 0 → 1
entry.Seq = a.sessionLogSeq  // Seq=1 から開始
```

バックエンドからは `Seq >= 1` のエントリのみ送信されるため、フロントエンドの `isValidSeq(seq > 0)` と整合します。**本番コード確認の結果、この問題は設計通りで修正不要です。**

ただし、コメントに「Seq は 1 から始まる」という仕様を明記することを推奨します。

---

### CRIT-02: `cleanupOldSessionLogs` の削除カウンタに論理的バグの可能性

**ファイル:** `app_session_log.go` L87-L112  
**深刻度:** CRITICAL  

```go
deleted := 0
for _, name := range logFiles {
    if deleted >= excess {
        break
    }
    if name == currentFile {
        // Never delete the active session log file for this process.
        continue  // ← deleted をインクリメントせずにスキップ
    }
    ...
    deleted++
}
```

`currentFile` をスキップしても `deleted` はインクリメントされないため、実際に削除するファイル数は `excess` 個となりますが、スキップ分だけ余分に削除する可能性があります。

**具体例:** logFiles = [A, current, B, C, D], excess=2  
- A 削除 → deleted=1  
- current スキップ → deleted=1  
- B 削除 → deleted=2 → break  

この場合は正常ですが、logFiles = [current, A, B, C, D], excess=2 の場合:  
- current スキップ → deleted=0  
- A 削除 → deleted=1  
- B 削除 → deleted=2 → break  

**結果:** excess=2 個の削除が完了 — 正常動作です。ただし以下の edge case で問題が生じます:

logFiles = [A, B, current, C, D, E], excess=3, A,B は古い  
- A 削除 → deleted=1  
- B 削除 → deleted=2  
- current スキップ  
- C 削除 → deleted=3 → break

この場合、本来は excess=3 を超えて削除されていないように見えますが、currentをスキップしても `excess` 個削除されます。ただし `excess = len(logFiles) - sessionLogMaxFiles` は total ファイル数から計算されており、current を含めた総数に基づいているため、current をスキップするなら `excess` を1減らす必要があります:

```
total = N files including current
excess = N - sessionLogMaxFiles
```

current が存在する場合、実際に削除可能なのは `N-1` ファイルです。もし `N-1 < sessionLogMaxFiles` のケースでも `excess > 0` になり得ます (N = sessionLogMaxFiles+1, current あり → N-1 = sessionLogMaxFiles → 削除不要)。

**修正案:**
```go
// current を除いた論理ファイル数でexcessを再計算、またはcurrentをスキップ時はexcessをデクリメント
```

テスト `TestCleanupOldSessionLogs_PreservesCurrentFile` が追加されているため、現状のロジックを具体的にテストして確認する必要があります。

---

### CRIT-03: `models.ts` の `SessionLogEntry` 定義変更 — 後方互換性の欠如

**ファイル:** `frontend/wailsjs/go/models.ts`  
**深刻度:** CRITICAL（フロントエンド自動生成ファイル）  

```typescript
// 変更前: コンストラクタに seq フィールドなし
constructor(source: any = {}) {
    this.ts = source["ts"];
    ...
}

// 変更後: seq フィールドが先頭に追加
constructor(source: any = {}) {
    this.seq = source["seq"];
    this.ts = source["ts"];
    ...
}
```

`models.ts` は Wails の自動生成ファイルです。`seq` フィールドが Go 側の `SessionLogEntry` に追加されたため自動生成で反映されますが、**`seq` のデフォルト値が設定されていません**。

バックエンドから `seq=0` のエントリが来た場合（例: テストモックや旧バージョンのバックエンドから）、`isValidSeq(0)` は `false` を返し、エントリ全体が `normalizeEntries` でフィルタリングされてしまいます。特に既存のJSONLファイルから読み込んだ古いエントリ（`seq` フィールドなし）は `seq=0` として扱われ、表示されません。

**修正案:** 既存のエントリに対して `seq=0` を特別扱いするか、`models.ts` でデフォルト値を設定する:
```typescript
this.seq = source["seq"] ?? 0;
```

または `errorLogStore.ts` の `isValidSeq` を：
```typescript
return typeof seq === "number" && Number.isFinite(seq) && seq >= 0;
```
と変更し、`seq=0` を「レガシーエントリ」として扱う。

---

## 3. Important Issues (対応推奨) — 9件

### IMP-01: `parseDiffHeaderPaths` — パス長偶数時のフォールバックは名目上の問題

**ファイル:** `app_devpanel_api.go` 内 `parseDiffHeaderPaths`  

コメントに「Even total lengths (after removing "a/") intentionally fail this check」とありますが、実際には `pathLen = (len(content) - 3) / 2` の整数除算により、奇数/偶数の違いで正しく分岐するかどうか不明確な箇所があります。

ファイル名が1文字の場合 (例: `a/b b/b`):
- `content = "b b/b"` (len=5)
- `pathLen = (5-3)/2 = 1`
- `2*1+3 = 5 == 5` → candidate = "b", check content[1:4] == " b/" ✓, content[4:] == "b" ✓

正常動作します。ただしパスに `b/` を含む複雑なケース（テストでカバーされている）でのフォールバック動作の妥当性を文書化すること。

---

### IMP-02: `isPathWithinBase` — Windows での大文字小文字非区別の問題 (本番コード確認済み)

**ファイル:** `app_worktree_api.go` L645-L654 (本番コード確認済み)  

```go
func isPathWithinBase(path, base string) bool {
    relPath, err := filepath.Rel(base, path)
    if err != nil {
        return false
    }
    if relPath == ".." || strings.HasPrefix(relPath, ".."+string(filepath.Separator)) {
        return false
    }
    return true
}
```

**問題:** `filepath.Rel` は OS のファイルシステムが大文字小文字を区別しない場合でも、**文字列比較として大文字小文字を区別します**。Windows では `C:\Users\Foo` と `C:\users\foo` は同じパスですが、`filepath.Rel` は "等しくない" として扱います。

具体的なリスク:
- `resolvedBase = "C:\\Users\\Foo"`, `resolvedAbs = "C:\\users\\foo\\evil.txt"` が渡ると
- `filepath.Rel("C:\\Users\\Foo", "C:\\users\\foo\\evil.txt")` は `"..\..\users\foo\evil.txt"` のような相対パスを返し
- `strings.HasPrefix(relPath, "..")` で **correctly** rejected されます

ただし逆方向:
- `resolvedBase = "C:\\users\\foo"`, `absPath = "C:\\Users\\Foo\\safe.txt"` → `filepath.Rel` は "safe.txt" を返す可能性あり

`filepath.EvalSymlinks` は OS のシステムコールでパスを正規化するため、resolvedBase は常に実際のケースで返されます。呼び出し側で `EvalSymlinks` によりケースを正規化してから `isPathWithinBase` を呼んでいるため、**本番コードでは正常動作します**。  

ただし `buildUntrackedFileDiffSingleWithResolvedBase` の1回目チェック:
```go
if !isPathWithinBase(absPath, workDir) {  // absPath は EvalSymlinks 前
```
は `workDir` (EvalSymlinks 前) と `absPath` (Join のみ) を比較しており、ケースの不一致リスクがあります。

**修正推奨:** 1回目のレキシカルチェックにコメントを追加し、リスクを文書化してください。または `absPath` を EvalSymlinks に渡してから比較する（ただし EvalSymlinks は存在確認も行うため、存在しないパスに使えない点を考慮）。

---

### IMP-03: `useBackendSync.ts` — `fetchErrorLog` のリトライ最大回数が1回のみ

**ファイル:** `frontend/src/hooks/useBackendSync.ts`  

```typescript
if (attempt >= 1) {
    return;  // 1回だけリトライ → 最大2回試行
}
```

リトライが1回のみです。ネットワークの一時的な輻輳やバックエンドの一時的な負荷でエラーになった場合、エラーログが正常に表示されません。2回程度の試行で十分かもしれませんが、コメントで意図を明記してください。

---

### IMP-04: `errorLogStore.ts` — `lastReadSeq` の後退処理が不完全

**ファイル:** `frontend/src/stores/errorLogStore.ts`  

```typescript
// Backend restart resets seq to 1. If the latest seq regresses, clear read marker.
if (maxNewSeq > 0 && maxNewSeq < lastReadSeq) {
    lastReadSeq = maxNewSeq;
}
// On first load, treat pre-existing history as already read.
if (state.entries.length === 0 && state.lastReadSeq === 0 && maxNewSeq > 0) {
    lastReadSeq = maxNewSeq;
}
```

バックエンド再起動でシーケンスがリセットされると `maxNewSeq < lastReadSeq` が成立し `lastReadSeq = maxNewSeq` になりますが、この時点で `unreadCount` の再計算が行われます。

**問題:** `state.entries` が空でなく `state.lastReadSeq > 0` の場合、かつバックエンド再起動後に全エントリが既読扱いになるかどうか確認が必要です。`lastReadSeq = maxNewSeq` にしてから unreadCount を再計算するため全エントリが「既読」になります — これは意図通りか？

---

### IMP-05: `viewerRegistry.ts` — グローバルオブジェクトへの `Symbol.for` キー使用

**ファイル:** `frontend/src/components/viewer/viewerRegistry.ts`  

```typescript
const REGISTRY_KEY = Symbol.for("mytx.viewer.registry");
type RegistryGlobal = typeof globalThis & {
    [key: symbol]: unknown;
};
```

`Symbol.for` は Global Symbol Registry を使用するため、異なるモジュールインスタンス間で共有されます。HMR 対応のために使っているとのことですが、テスト環境では意図しない状態共有が発生する可能性があります。

**潜在的問題:** Jest/Vitest などのテスト環境では、テスト間でグローバルオブジェクトがリセットされない限り、レジストリの状態が持続します。テストにおけるクリーンアップ戦略を文書化してください。

---

### IMP-06: `DiffViewer.tsx` — `if (!match) continue` のロジック変更

**ファイル:** `frontend/src/components/viewer/views/git-graph/DiffViewer.tsx`  

```typescript
// Before
if (match) {
    oldLine = parseInt(match[1], 10);
    newLine = parseInt(match[2], 10);
}
currentHunk = { header: line, lines: [] };

// After
if (!match) continue;
oldLine = parseInt(match[1], 10);
newLine = parseInt(match[2], 10);
currentHunk = { header: line, lines: [] };
```

**重要な動作変更:** match がない場合、元は `currentHunk = { header: line, lines: [] }` が実行されていましたが、変更後は `continue` でスキップされます。つまり **`@@` で始まるがhunkヘッダーとしてパースできない行**は以前はhunkとして追加されていましたが、今は無視されます。

これは意図通りの修正（バグフィックス）か確認してください。hunkヘッダー解析失敗時に `currentHunk` を null のまま残すことで、後続の行が正しくスキップされることを確認する必要があります。

---

### IMP-07: `app_devpanel_api.go` — `DevPanelWorkingDiff` の並列性なし

**ファイル:** `app_devpanel_api.go` `DevPanelWorkingDiff`  

`git diff HEAD` と `git ls-files` は独立した操作ですが、逐次的に実行されています:
```go
output, gitErr = gitpkg.RunGitCLIPublic(workDir, ...) // git diff HEAD
...
untrackedFiles, hasLsErr := collectUntrackedFiles(workDir) // git ls-files
```

大きなリポジトリでは、この2つを並行実行することでレスポンスタイムを改善できます。ただし、並行化のコストとメリットのトレードオフを評価してください。

---

### IMP-08: `handleNewWindow` — スナップショット再取得失敗時のロールバックは正しいが、セッション名の生成ロジックを確認すること

**ファイル:** `internal/tmux/command_router_handlers_window.go`  

```go
newSessionSnap, snapOk := getSession(newSessionName)
if !snapOk {
    return rollbackSession("snapshot-refetch", fmt.Errorf("session disappeared during setup: %s", newSessionName))
}
```

`newSessionName` がエラーメッセージに含まれますが、このセッション名がユーザー入力由来である場合、ログインジェクション攻撃の可能性があります（ただし `app_devpanel_api.go` でのサニタイズを確認）。`slog.Warn` に含まれているため影響は限定的です。

---

### IMP-09: `ErrorLogView.tsx` — `useLayoutEffect` の依存配列に `entries` を含めることで誤った読み取り動作

**ファイル:** `frontend/src/components/viewer/views/error-log/ErrorLogView.tsx`  

```tsx
// Intentional: while this view is open, newly appended entries are immediately marked as read.
useLayoutEffect(() => {
    markAllRead();
}, [entries, markAllRead]);
```

エラーログビューが開いている間は `entries` が変わるたびに `markAllRead()` が呼ばれます。これは「ビューが開いている間は新着エントリを即座に既読にする」という意図ですが、`unreadCount` のバッジ表示に影響します。

**問題:** ユーザーがビューを開いたまま新しいエラーが来ると、バッジのカウントが一瞬上がってすぐに0に戻ります。これはUXとして問題ないかもしれませんが、`markAllRead()` が `lastReadSeq` を更新するため、ビューを閉じた後に追加されたエントリが「既読」と誤判定される可能性があります。

**確認事項:** `markAllRead()` が `lastReadSeq` を現在の最大 seq に設定することで、ビューを閉じた後に来るエントリは正しく「未読」として扱われるか？ → `markAllRead` の実装 (`state.entries.at(-1)?.seq`) より、現在のスナップショットの最大 seq が設定されます。ビューを閉じた後の新着エントリは seq がその値より大きいため未読として扱われます — **正常動作です。**

---

## 4. Suggestions (改善提案) — 8件

### SUG-01: `app_devpanel_api.go` — `buildUntrackedFileDiffs` の公開関数が不要

```go
// buildUntrackedFileDiffs creates synthetic diff entries...
func buildUntrackedFileDiffs(workDir, relPath string) []WorkingDiffFile {
    results, _ := buildUntrackedFileDiffsWithBudget(workDir, relPath, -1)
    return results
}
```

`buildUntrackedFileDiffs` はテスト専用のラッパー関数ですが、パッケージ内部関数（小文字）です。`buildUntrackedFileDiffsWithBudget` の第3引数に `-1` を渡すことを `buildUntrackedFileDiffs` が担うのは良い設計ですが、この関数はテストからしか呼ばれないため、テストファイルに移動することを検討しても良いでしょう。

---

### SUG-02: `WorkingDiffStatus = string` — 型エイリアスの意図をもう少し明確化

**ファイル:** `app_devpanel_types.go`  

```go
// NOTE: This is a type alias (= string), not a defined type.
type WorkingDiffStatus = string
```

コメントに「型安全性は犠牲にした」とありますが、将来的に Wails が型エイリアスに対応した際のマイグレーションパスをコメントに追記しておくことを推奨します。

---

### SUG-03: `useBackendSync.ts` — デバウンスタイマーの変数名変更

```typescript
let errorLogDebounceTimer: ReturnType<typeof setTimeout> | null = null;
let errorLogRetryTimer: ReturnType<typeof setTimeout> | null = null;
```

変数名は明確ですが、クリーンアップ関数内で `clearTimeout` の後に `null` を代入しているパターンが複数箇所あります。`clearAndNullTimer` のようなユーティリティ関数にまとめると保守性が向上します。

---

### SUG-04: `sessionLogRingBuffer.push` — 変数名の変更は良い

**ファイル:** `app_session_log_types.go`  

```go
// Before: cap (組み込み関数とのシャドーイング)
cap := len(rb.buf)

// After: 適切な名前
bufCap := len(rb.buf)
```

`cap` という変数名は Go の組み込み関数 `cap()` をシャドーイングするため、`bufCap` への名前変更は良い改善です。

---

### SUG-05: `handler.go` — callback の panic recovery の粒度

**ファイル:** `internal/sessionlog/handler.go`  

```go
func() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Fprintf(os.Stderr, ...)
        }
    }()
    h.callback(record.Time, record.Level, record.Message, h.group)
}()
```

即時実行関数でパニックを回収するパターンは正しいですが、`stacktrace` の書き出し (`debug.Stack()`) は意図した通りです。ただし、本番環境では非常に大量のスタックトレースが stderr に書き出される可能性があるため、スタックトレースの出力サイズを制限することを検討してください。

---

### SUG-06: `injectTestWindow` — テスト内部状態直接操作はドキュメント化が必要

**ファイル:** `internal/tmux/command_router_test_helpers_test.go`  

```go
// NOTE: Callers must NOT hold manager.mu when calling this function.
func injectTestWindow(t *testing.T, manager *SessionManager, ...) (*TmuxWindow, *TmuxPane) {
    t.Helper()
    manager.mu.Lock()
    defer manager.mu.Unlock()
```

内部ロックを直接取得し、`nextWindowID`, `nextPaneID` などの内部フィールドを操作しています。"Callers must NOT hold manager.mu" というコメントはありますが、このヘルパーが内部実装の詳細に依存していることを明示してください。将来的に `SessionManager` のロック構造が変わった場合にここのテストが壊れます。

---

### SUG-07: `ViewerSystem.tsx` — `registryVersion` の状態は不要かもしれない

**ファイル:** `frontend/src/components/viewer/ViewerSystem.tsx`  

```tsx
const [registryVersion, setRegistryVersion] = useState(0);
useEffect(() => {
    return subscribeRegistry(() => {
        setRegistryVersion((version) => version + 1);
    });
}, []);
const views = useMemo(() => getRegisteredViews(), [registryVersion]);
```

`registryVersion` カウンターパターンは機能しますが、`useRef` + 強制再レンダリングのパターンと比較して判断してください。HMRの場合にのみ再登録が発生するため、このオーバーヘッドは許容範囲です。

---

### SUG-08: CSS変数の命名統一

**ファイル:** `frontend/src/styles/base.css`  

```css
--warning: rgb(246, 173, 85);
--warning-10: rgba(246, 173, 85, 0.1);
```

`--danger` 変数は `--danger-08`, `--danger-20`, `--danger-40` というパターンですが、`--warning` は `-10` のみです。将来の拡張に備えて、`--warning-08`, `--warning-20` なども追加しておくか、命名規則を統一することを推奨します。

---

## 5. Positive Observations (良い点)

### ✅ ping+fetch アーキテクチャへの移行

`app:error-logged` から `app:session-log-updated`（ペイロードなしping）への変更は、throttling によるデータ消失リスクを根本的に解消する優れた設計です。

### ✅ `Seq` フィールドによる安定的なデデュプリケーション

タイムスタンプ+メッセージによる複合キーから単調増加の `seq` による識別子への変更は、衝突リスクが低く React の `key` prop としても最適です。

### ✅ `TeeHandler.Handle` のコールバック無視変更

```go
// Before: base handler エラー時にコールバック未実行
if err != nil { return err }

// After: base handler エラーに関わらずコールバック実行
err := h.base.Handle(ctx, record)
// callback always runs...
return err
```

ディスク障害時もUIへの通知が行われるよう改善された点は重要なバグ修正です。

### ✅ rollback エラーの隠蔽修正

```go
// Before: rollback失敗情報がクライアントに漏れる
return errResp(fmt.Errorf("%w (rollback failed: %v)", originalErr, rmErr))

// After: 元のエラーのみ返却
return errResp(originalErr)
```

内部実装の詳細をクライアントに漏らさない方針は適切です。

### ✅ TOCTOU 保護

`buildUntrackedFileDiffSingleWithResolvedBase` での二重チェック（Lstat + EvalSymlinks）は path traversal via symlink hop を正しく防いでいます。

### ✅ テストカバレッジの大幅向上

`TestDetectFreshRepoState`, `TestBuildUntrackedFileDiffSingle_*`, `TestWriteSessionLogEntry_SeqMonotonicallyIncreasing` など、新機能に対する包括的なテストが追加されています。

### ✅ `stubRuntimeEventsEmit` ヘルパーへの集約

テストコードの `runtimeEventsEmitFn` モック設定の重複をヘルパー関数に集約したことで、保守性が向上しています。

---

## 6. 本番コード周辺の影響確認

### 6.1 イベント名変更の影響範囲

| 変更前 | 変更後 | 影響ファイル |
|---|---|---|
| `app:error-logged` | `app:session-log-updated` | `useBackendSync.ts`, `app_session_log.go`, `app_session_log_test.go` |

**確認済み:** `BackendEventMap` の型定義も更新されており、旧イベント名は削除されています。フロントエンドのイベントハンドラーも更新済みです。

### 6.2 `SessionLogEntry` の後方互換性

既存の JSONL ファイルは `seq` フィールドを持たないため、再起動後の初回読み込み時に `seq=undefined` → `isValidSeq` で `false` → フィルタリングされます。**CRIT-03** で指摘した通り、これは既存ログの消失を意味します。

### 6.3 `app:window-created` イベントポリシーの追加

```go
"tmux:window-created": {trigger: true, bypassDebounce: true},
```

ポリシーが追加されましたが、現状このイベントを emit している箇所は存在しません。テストでも `wantEventName: "tmux:window-created"` のテストケースがないことを確認しました。将来への準備として追加されており、意図通りです。

### 6.4 `removeWindowAtIndexLocked` の変更

```go
// Before
removedPanes := make([]*TmuxPane, len(window.Panes))
copy(removedPanes, window.Panes)

// After
capHint := 0
if window != nil { capHint = len(window.Panes) }
removedPanes := make([]*TmuxPane, 0, capHint)
if window != nil { removedPanes = append(removedPanes, window.Panes...) }
```

**重要な動作変更:** `window == nil` の場合:
- Before: `removedPanes = make([]*TmuxPane, len(nil.Panes))` → パニックをキャッチできていた可能性
- After: `removedPanes = make([]*TmuxPane, 0, 0)` → 空スライス、安全

`window != nil` の場合:
- Before: `copy` でスライスのコピー（要素はポインタ、シャローコピー）
- After: `append` でポインタのコピー（同等）

動作的には等価ですが、コメントに「nil から 空スライスへ変更した理由」が書かれており、意図が明確です。

---

## 7. タスク一覧と並列作業可否表

以下の表は、指摘事項を修正タスクとして整理したものです。  
各タスクの「並列作業」列は、他のタスクと独立して並行修正できるかを示します。

| # | タスクID | 対象ファイル | 内容 | 優先度 | 並列作業 | 注意事項 |
|---|---|---|---|---|---|---|
| 1 | CRIT-01 | `app.go` | `sessionLogSeq`は uint64 ゼロ値=0 のため設計通り。コメントに「Seq は 1 から始まる」を追記推奨 | ✅ 解消 | ✅ 可 | コメント追記のみでOK |
| 2 | CRIT-02 | `app_session_log.go` | `cleanupOldSessionLogs` の削除カウンタロジック検証と修正 | 🔴 Critical | ✅ 可 | CRIT-01と独立 |
| 3 | CRIT-03 | `frontend/src/stores/errorLogStore.ts`, `frontend/wailsjs/go/models.ts` | `seq=0` (旧フォーマット) のエントリ扱いを決定・修正 | 🔴 Critical | ✅ 可 | フロントのみに閉じた修正 |
| 4 | IMP-01 | `app_devpanel_api.go` | `parseDiffHeaderPaths` のパス長偶数時のフォールバック文書化 | 🟡 Important | ✅ 可 | コメント追記のみ |
| 5 | IMP-02 | `app_devpanel_api.go` | `isPathWithinBase` の実装を確認し Windows大文字小文字対応を検証 | 🟡 Important | ✅ 可 | 読み取り調査のみ |
| 6 | IMP-03 | `frontend/src/hooks/useBackendSync.ts` | `fetchErrorLog` リトライ戦略の意図をコメントで明記 | 🟡 Important | ✅ 可 | コメント追記のみ |
| 7 | IMP-04 | `frontend/src/stores/errorLogStore.ts` | バックエンド再起動時の `lastReadSeq` 後退処理を確認・テスト追加 | 🟡 Important | ✅ 可 | フロントのみ |
| 8 | IMP-05 | `frontend/src/components/viewer/viewerRegistry.ts` | テスト環境でのグローバルシンボルレジストリクリーンアップ戦略を文書化 | 🟡 Important | ✅ 可 | コメント追記のみ |
| 9 | IMP-06 | `frontend/src/components/viewer/views/git-graph/DiffViewer.tsx` | `if (!match) continue` の動作変更が意図通りか確認・コメント追記 | 🟡 Important | ✅ 可 | 確認のみ |
| 10 | IMP-07 | `app_devpanel_api.go` | `git diff HEAD` と `git ls-files` の並列化検討 | 🟡 Important | ✅ 可 | パフォーマンス改善 |
| 11 | IMP-08 | `internal/tmux/command_router_handlers_window.go` | `newSessionName` のエラーメッセージへの含め方を確認 | 🟡 Important | ✅ 可 | セキュリティ確認のみ |
| 12 | IMP-09 | `frontend/src/components/viewer/views/error-log/ErrorLogView.tsx` | `useLayoutEffect` の `entries` 依存の動作確認 | 🟡 Important | ✅ 可 | 実装確認のみ |
| 13 | SUG-01 | `app_devpanel_api.go` | `buildUntrackedFileDiffs` をテストオンリーに移動検討 | 🔵 Suggestion | ✅ 可 | リファクタリング |
| 14 | SUG-02 | `app_devpanel_types.go` | `WorkingDiffStatus` 型エイリアスの将来マイグレーションパスを文書化 | 🔵 Suggestion | ✅ 可 | コメント追記 |
| 15 | SUG-03 | `frontend/src/hooks/useBackendSync.ts` | `clearAndNullTimer` ユーティリティ関数の作成検討 | 🔵 Suggestion | ✅ 可 | リファクタリング |
| 16 | SUG-04 | - | 変数名 `bufCap` への変更は完了済み（承認） | - | - | 対応不要 |
| 17 | SUG-05 | `internal/sessionlog/handler.go` | `debug.Stack()` の出力サイズ制限を検討 | 🔵 Suggestion | ✅ 可 | コメント追記 |
| 18 | SUG-06 | `internal/tmux/command_router_test_helpers_test.go` | `injectTestWindow` の内部依存に関する警告コメント強化 | 🔵 Suggestion | ✅ 可 | コメント追記 |
| 19 | SUG-07 | `frontend/src/components/viewer/ViewerSystem.tsx` | `registryVersion` カウンターパターンの採用判断の文書化 | 🔵 Suggestion | ✅ 可 | コメント追記 |
| 20 | SUG-08 | `frontend/src/styles/base.css` | `--warning-*` CSS変数の命名規則統一 | 🔵 Suggestion | ✅ 可 | CSS変数追加 |

---

## 8. 修正優先順位と推奨アクション

```
1. CRIT-03（最優先）: 旧フォーマットのsession log が表示されない問題
   → frontend/stores/errorLogStore.ts の isValidSeq を seq >= 0 に変更、
     またはデフォルト値を明示する

2. CRIT-02: cleanupOldSessionLogs のカウンタロジック
   → テスト TestCleanupOldSessionLogs_PreservesCurrentFile を実行して
     実際の動作を確認し、必要に応じて修正

3. CRIT-01: sessionLogSeq の初期化
   → app.go の NewApp() で sessionLogSeq の初期化を明示

4. IMP-06: DiffViewer.tsx の動作変更確認
   → リグレッションがないことをE2Eテストで確認

5. IMP-02: isPathWithinBase の Windows対応確認
   → 本番コード調査、必要なら filepath.HasPrefix 的な処理を確認

6. 残りのIMP/SUGは並列対応可能
```

---

## 9. 総合評価

| 観点 | 評価 | コメント |
|---|---|---|
| 機能実装品質 | ★★★★☆ | `DevPanelWorkingDiff` は堅牢な実装。パストラバーサル防止も適切 |
| エラーハンドリング | ★★★★☆ | rollbackエラー隠蔽の修正、TeeHandler改善は高品質 |
| テストカバレッジ | ★★★★★ | 新機能に対する包括的なテストが揃っている |
| 後方互換性 | ★★☆☆☆ | seq フィールド追加により旧フォーマットのログが表示されなくなる |
| セキュリティ | ★★★★☆ | TOCTOU防止、パストラバーサル防止は適切 |
| コード品質 | ★★★★☆ | ログプレフィックス統一、変数名改善は良好 |
| フロントエンド設計 | ★★★★☆ | ping+fetchモデルは適切。HMR対応も考慮されている |

**マージ判定:** CRIT-02, CRIT-03 の修正後にマージを推奨します。CRIT-01 は本番コード確認により解消済みです。
