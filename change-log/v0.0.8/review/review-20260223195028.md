# PR Review - 20260223195028

## 変更概要

コミット前レビュー（5エージェント並列実行）。

### 変更カテゴリ
- **Go Backend Core**: app.go, app_devpanel_api.go, app_lifecycle.go, app_pane_api.go, app_session_log.go
- **Go Input History (新機能)**: app_input_history.go, app_input_history_types.go, app_input_history_test.go
- **Go Internal / Tests**: app_session_api_test.go, app_session_log_test.go, internal/config/config.go, internal/config/config_test.go, internal/testutil/helpers.go, internal/tmux/command_router_env_test.go, internal/tmux/command_router_handlers_window_test.go, config.yaml
- **Frontend Settings**: SettingsModal.tsx, KeybindSettings.tsx, settingsReducer.ts, settingsValidation.ts, types.ts, ViewerShortcutSettings.tsx (新規), tmux.ts
- **Frontend Viewer + Core**: ActivityStrip.tsx, ViewerSystem.tsx, viewerRegistry.ts, useBackendSync.ts, main.tsx, api.ts, ErrorBoundary.tsx (新規), inputHistoryStore.ts (新規), InputHistoryView.tsx (新規), useInputHistory.ts (新規), InputHistoryIcon.tsx (新規), input-history/index.ts (新規), wailsjs/*

---

## Critical Issues（必須修正） - 3件

### C-1: `internal/testutil/helpers.go` — `new(v)` はコンパイルエラー
**ファイル**: `myT-x/internal/testutil/helpers.go`

```go
// 現在（バグ）
//go:fix inline
func Ptr[T any](v T) *T { return new(v) }
```

Goの`new`組み込み関数は**型**を引数に取る（`new(T)`）。`v`はジェネリクスの**値**であり型名ではないためコンパイルエラーになる。`//go:fix inline`ディレクティブを付けるなら本体は`return &v`のままで良い。

```go
// 正しい実装
//go:fix inline
func Ptr[T any](v T) *T { return &v }
```

---

### C-2: `app_session_api_test.go` / `command_router_env_test.go` / `command_router_handlers_window_test.go` — `new(true)` / `new(false)` はコンパイルエラー（20箇所）
**ファイル**:
- `myT-x/app_session_api_test.go` (4箇所)
- `myT-x/internal/tmux/command_router_env_test.go` (14箇所)
- `myT-x/internal/tmux/command_router_handlers_window_test.go` (2箇所)

```go
// 現在（バグ）
wantUseClaudeEnv: new(true),   // コンパイルエラー：true は型ではなく値
wantUsePaneEnv:   new(false),  // コンパイルエラー
```

`true`/`false`はbool**値**（定数）であり、型ではない。`new(true)`はコンパイルエラー。かつ`command_router_env_test.go`と`command_router_handlers_window_test.go`では`testutil`インポートも削除されているため、`testutil.Ptr`の呼び出し元も壊れている。これらは全て元に戻す必要がある。

```go
// 正しい実装
wantUseClaudeEnv: testutil.Ptr(true),
wantUsePaneEnv:   testutil.Ptr(true),
```

**根本原因**: `//go:fix inline`ディレクティブを追加した`Ptr`に対して`go fix`を実行すると`testutil.Ptr(true)` → `new(true)`という誤った変換が行われた模様。`go fix`の自動置換結果が無効。

---

### C-3: `myT-x/frontend/src/components/settings/settingsValidation.ts` — `import` 文がコード本体の後に配置
**ファイル**: `myT-x/frontend/src/components/settings/settingsValidation.ts`

```typescript
// L1
import type {ClaudeEnvEntry, OverrideEntry, PaneEnvEntry} from "./types";

// L3〜L30: validateViewerShortcuts 関数 ← 新規追加コードがここに挿入された

// L31（コード末尾）
import {EFFORT_LEVEL_KEY, MIN_OVERRIDE_NAME_LEN_FALLBACK, VALID_EFFORT_LEVELS} from "./constants"; // ← import が末尾に残存！
```

`import`文はモジュールの先頭に置く必要がある。TypeScript仕様上は静的ホイストされるため動作はするが、ESLint `import/first`ルール違反であり、CIで弾かれる可能性がある。`validateViewerShortcuts`を追加した際に既存`import`行の直前にコードを挿入したことで発生した。

**修正**: `import`文をファイル先頭（`import type {ClaudeEnvEntry...}`の直後）に移動する。

---

## Important Issues（重要） - 15件

### I-1: `app_input_history.go` — `flushLineBuffer` がアクティブなタイマー参照を上書きするバグ（タイマー漏れ・二重フラッシュ）
**ファイル**: `myT-x/app_input_history.go`

`flushLineBuffer`内の`lb.timer = nil`が**アクティブな新タイマーT2の参照**を破壊する競合シナリオ:

```
t=0:    'h' 入力 → T1 作成, lb.timer = T1
t=5s:   T1 発火（goroutineスケジュール済み・未実行）
t=5s+ε: 'e' 入力 → resetLineBufferTimer: T1.Stop()=false（firing済み）→ lb.timer = T2 設定
t=5s+2ε: T1 goroutineがロック取得 → "he"をフラッシュ → lb.timer = nil ← T2参照を消去！
t=10s+ε: T2が発火（誰もStop()できない）→ その時点のバッファを不正にフラッシュ
```

`time.AfterFunc`の`Stop()`は「goroutineの実行を保証しない」（Go仕様通り）で、フラッシュ後に`lb.timer = nil`を無条件実行するため後続タイマーの参照が消える。

**修正方針**: ジェネレーションカウンタ方式

```go
type inputLineBuffer struct {
    // ...
    timerGen uint64  // resetLineBufferTimer 呼び出しごとにインクリメント
}

func (a *App) resetLineBufferTimer(lb *inputLineBuffer) {
    if lb.timer != nil { lb.timer.Stop() }
    lb.timerGen++
    gen := lb.timerGen
    paneID := lb.paneID
    lb.timer = time.AfterFunc(inputLineFlushTimeout, func() {
        a.flushLineBufferIfGen(paneID, gen)
    })
}

func (a *App) flushLineBufferIfGen(paneID string, gen uint64) {
    a.inputLineBufMu.Lock()
    lb, exists := a.inputLineBuffers[paneID]
    if !exists || lb == nil || lb.timerGen != gen {
        a.inputLineBufMu.Unlock()
        return // stale timer goroutine
    }
    // ... 既存の flushLineBuffer ロジック
}
```

---

### I-2: `app_lifecycle.go` — `initInputHistory()` が TeeHandler 設定より前に呼ばれ、slog.Warn がセッションログに記録されない
**ファイル**: `myT-x/app_lifecycle.go` (147行付近)

```go
a.initSessionLog()
a.initInputHistory()   // ← ここで slog.Warn/Info を呼ぶ
...
slog.SetDefault(slog.New(teeHandler))  // ← TeeHandler は後で設定
```

`initInputHistory()`内の`slog.Warn("[input-history] failed to ...")`はTeeHandlerが未設定のためセッションログに記録されず、stderrのみ出力される。`initSessionLog()`も同様の問題があるが新規コードとして認識が必要。

**修正案**: `initInputHistory()`の呼び出しを`slog.SetDefault(...)`の後に移動する（`initSessionLog()`との依存関係を確認した上で）。

---

### I-3: `app_input_history.go` — シャットダウン時タイマーgoroutineが`bgWG`で追跡されていない
**ファイル**: `myT-x/app_input_history.go`, `myT-x/app_lifecycle.go`

`time.AfterFunc`で起動した`flushLineBuffer`コールバックは`bgWG`に登録されていない。シャットダウン時に以下の競合窓がある:

1. タイマーgoroutineが`inputLineBufMu`を取得してバッファを読み取りアンロード
2. `flushAllLineBuffers()`がその直後実行（バッファが空 → 保留リストに追加されない）
3. `closeInputHistory()`が`inputHistoryFile = nil`にクローズ
4. タイマーgoroutineが`writeInputHistoryEntry()`を呼ぶが`inputHistoryFile == nil` → JSOLへの書き込みがスキップされる

**結果**: シャットダウン直前のキーストロークがJSONLファイルに保存されずに消失する可能性がある。

**修正案**: `resetLineBufferTimer`内で専用の`timerWG`を使用し、`flushAllLineBuffers()`の冒頭で待機する。

---

### I-4: `app_session_log_test.go` — `TestLogFrontendEvent_WritesToSessionLog` でメッセージ本文の検証が欠落
**ファイル**: `myT-x/app_session_log_test.go`

levelとsourceは検証しているが`result[0].Message`の検証がない。`LogFrontendEvent`がメッセージを空文字や別の値で保存しても検出できない。

```go
// 追加すべき検証
if result[0].Message != strings.TrimSpace(tt.msg) {
    t.Errorf("message = %q, want %q", result[0].Message, strings.TrimSpace(tt.msg))
}
```

---

### I-5: `app_session_log_test.go` — sourceに空白を含むテストケースが欠如
**ファイル**: `myT-x/app_session_log_test.go`

source比較で`strings.TrimSpace(tt.source)`を使って「本番コードがsourceをトリムする」という仕様を検証しているが、全テストケースのsource値には前後空白がない。意味のある検証とするため以下のケースが必要:

```go
{
    name:          "source with whitespace trimmed",
    level:         "warn",
    msg:           "some message",
    source:        "  frontend/ui  ",
    expectedLevel: "warn",
    expectEntry:   true,
},
```

---

### I-6: `app_input_history_test.go` — タイマーキャンセルテスト（Enter後にlb.timer=nilになること）が欠如
**ファイル**: `myT-x/app_input_history_test.go`

`flushLineBuffer`を直接呼び出すテストは機能するが、以下が未テスト:
- Enter受信後にタイマーが正しくキャンセルされること（`lb.timer.Stop()`が呼ばれること）
- タイマー競合（旧タイマーgoroutineがフラッシュ後の新バッファを巻き込まないこと）

```go
// 追加すべきテスト
func TestRecordInput_TimerCancelledOnEnter(t *testing.T) {
    a := &App{...}
    a.recordInput("%1", "hello", "keyboard", "")
    a.recordInput("%1", "\r", "keyboard", "")
    
    a.inputLineBufMu.Lock()
    lb := a.inputLineBuffers["%1"]
    hasTimer := lb != nil && lb.timer != nil
    a.inputLineBufMu.Unlock()
    
    if hasTimer {
        t.Error("expected lb.timer to be nil after Enter flush")
    }
}
```

---

### I-7: `app_input_history_test.go` — 並行テストでペーン別エントリの正確性を検証していない
**ファイル**: `myT-x/app_input_history_test.go`

`TestRecordInput_ConcurrentSafety`はエントリ数とseq順序のみ検証し、各エントリのPaneID・Input内容の正確性が未検証。ペーン間バッファ混信バグがあっても検出できない。

```go
// 追加すべき検証
paneEntries := make(map[string][]string)
for _, e := range result {
    paneEntries[e.PaneID] = append(paneEntries[e.PaneID], e.Input)
}
for i := range 10 {
    pid := fmt.Sprintf("%%%d", i)
    if len(paneEntries[pid]) != 5 {
        t.Errorf("pane %s: expected 5 entries, got %d", pid, len(paneEntries[pid]))
    }
}
```

---

### I-8: `internal/config/config.go` — `ViewerShortcuts`のバリデーションがない
**ファイル**: `myT-x/internal/config/config.go`

`PaneEnv`/`ClaudeEnv`は`sanitize`処理でキーバリデーションが行われているが、`ViewerShortcuts`には同等の処理がない。空キー・ヌルバイトを含むキー・未定義のビューIDが設定された場合、フロントエンドに不正値が渡る可能性がある。

---

### I-9: `myT-x/frontend/src/components/settings/settingsValidation.ts` + `ViewerShortcutSettings.tsx` — `VIEWER_VIEW_IDS`と`VIEWER_SHORTCUTS`の二重定義
**ファイル**:
- `myT-x/frontend/src/components/settings/settingsValidation.ts` (L5-7)
- `myT-x/frontend/src/components/settings/ViewerShortcutSettings.tsx` (L4-10)

同一のviewId一覧が両ファイルで重複定義されている。新しいビューを追加・削除する際に片方だけ更新した場合、バリデーション対象と表示項目が静かに乖離する。

**修正方針**: `VIEWER_SHORTCUTS`配列を共有の定数ファイルに移し、`VIEWER_VIEW_IDS`をそこから導出する。

---

### I-10: `myT-x/frontend/src/components/settings/types.ts` — `UPDATE_VIEWER_SHORTCUT`の`viewId`が`string`型で制約されていない
**ファイル**: `myT-x/frontend/src/components/settings/types.ts` (L57-58)

```typescript
| { type: "UPDATE_VIEWER_SHORTCUT"; viewId: string; value: string };
```

`viewId`が任意`string`のため、`VIEWER_VIEW_IDS`に存在しないキーをreducerに送れる。`typeof VIEWER_VIEW_IDS[number]`に型を絞るべき（I-9の修正と連動）。

---

### I-11: `myT-x/frontend/src/components/viewer/views/input-history/useInputHistory.ts` — 初回表示時の自動スクロール不発
**ファイル**: `myT-x/frontend/src/components/viewer/views/input-history/useInputHistory.ts` (L41-49)

```typescript
useEffect(() => {
    const el = bodyRef.current;
    if (!el) return;
    const isNearBottom = el.scrollHeight - el.scrollTop - el.clientHeight < 60;
    if (isNearBottom) { el.scrollTop = el.scrollHeight; }
}, [entries.length, registerBodyElement]); // ← registerBodyElementは参照不変
```

`registerBodyElement`は`useCallback(() => {...}, [])`で作成されているため**参照が変化しない**。依存配列は実質`[entries.length]`と等価。ビュー初回表示時点でfetchが完了済みで`entries.length`が変化しない場合、DOM要素がマウントされても`useEffect`が再実行されず**最下部への自動スクロールが行われない**。

**修正案**: `bodyRefCallback`内に直接スクロールロジックを追加し、`useEffect`の依存配列は`[entries.length]`に整理する。

---

### I-12: `myT-x/frontend/src/components/viewer/InputHistoryView.tsx` — `useLayoutEffect`の不適切な使用
**ファイル**: `myT-x/frontend/src/components/viewer/views/input-history/InputHistoryView.tsx` (L24-26)

```typescript
useLayoutEffect(() => {
    markAllRead();
}, [entries, markAllRead]);
```

`markAllRead()`はZustand storeの更新のみを行い、DOM操作を伴わない。`useLayoutEffect`はブラウザのペインティング前に同期実行されるためレンダリングをブロッキングする。`useEffect`で代替すべき。

---

### I-13: `myT-x/frontend/src/components/ErrorBoundary.tsx` — `componentStack`先頭行が空になる可能性
**ファイル**: `myT-x/frontend/src/components/ErrorBoundary.tsx` (L34-36)

```typescript
const rawSource = stack !== "" 
    ? `frontend/react ${stack.split("\n")[0]}` 
    : "frontend/react";
```

Reactの`componentStack`は`"\n    at ComponentName (file.tsx:1:1)"`のように先頭が改行で始まる場合がある。その場合`split("\n")[0]`は**空文字列**となり、`source`が`"frontend/react "`（末尾スペース付き）になる。

```typescript
// 修正案
const firstFrame = stack.split("\n").find(line => line.trim() !== "") ?? "";
const rawSource = firstFrame !== "" ? `frontend/react ${firstFrame.trim()}` : "frontend/react";
```

---

### I-14: `myT-x/frontend/src/components/viewer/ActivityStrip.tsx` — ビューIDのハードコードでバッジ追加のたびに修正が必要
**ファイル**: `myT-x/frontend/src/components/viewer/ActivityStrip.tsx` (L38-43)

```tsx
{view.id === "error-log" && unreadCount > 0 && <span className="viewer-strip-badge"/>}
{view.id === "input-history" && inputHistoryUnreadCount > 0 && <span className="viewer-strip-badge"/>}
```

バッジ付きビューが増えるたびに`ActivityStrip.tsx`の修正が必要。`ViewPlugin`インターフェースに`useUnreadCount?: () => number`のようなフックを持たせれば各ビューモジュール側で完結する。

また`renderViewButton`の`useCallback`依存配列がバッジ付きビューが増えるほど肥大する。

---

### I-15: `myT-x/frontend/src/components/viewer/ViewerSystem.tsx` — HMR `dispose`時にアイコンが全消えする
**ファイル**: `myT-x/frontend/src/components/viewer/viewerRegistry.ts`

```typescript
import.meta.hot.dispose(() => {
    registryState.plugins.length = 0; // クリア
    notifyRegistryListeners();        // 空状態で通知
});
```

`plugins`を空にしてから通知するため、各viewモジュールが再登録を完了するまでの数フレーム、ActivityStripのアイコンが全消えする（開発時のHMRフリッカー）。`notifyRegistryListeners()`の呼び出しを`dispose`ブロックから除き、`registerView`による通知のみに任せれば回避できる。

---

## Suggestions（提案） - 11件

### S-1: `app.go` — 独立ロックの一覧コメントにロック制約記述を追記
ロック一覧コメントとフィールドコメントの整合性: フィールドコメントには「inputLineBufMu → inputHistoryMu」という順序制約が記載されているが、クラスレベルの`// Independent locks:`一覧にこの方向制約がない。追記を推奨。また末尾のカンマが抜けている:
```go
//   inputHistoryMu, inputLineBufMu      ← カンマなし (スタイル不整合)
```

---

### S-2: `app_devpanel_api.go` — `ok0` という変数名が意図を伝えにくい
```go
} else if after, ok0 := strings.CutPrefix(line, "rename from "); ok0 {
```
`ok0`は外側の`ok`と区別するための命名だが、`hasRenameFrom`等の意味が伝わる名前の方が可読性が高い。

---

### S-3: `app_session_log.go` — `normalizeLogLevel`の"debug"→"info"の意図をコメントで明示
```go
default:
    return "info"
```
`"debug"`が`"info"`に無言でマップされる。将来的にデバッグログを精査する際に混乱の原因となりうる。意図をコメントで明示すること。

---

### S-4: `app_input_history.go` — `processInputString`の`\x7f`（DEL）が暗黙的に通過
コメントに「`\x7f (DEL)` を保持」と明記されているが、コード上では`r >= 0x20`（127 >= 32 = true）によって暗黙的に通過する。`\x08`（Backspace）は明示的に列挙されているにもかかわらず`\x7f`だけ暗黙扱いで読者が誤解しやすい。コメントで補記すること:
```go
// r >= 0x20 covers printable ASCII, Unicode, and \x7f (DEL used as Backspace).
```

---

### S-5: `app_input_history.go` — `cleanupOldInputHistory`の`strings.TrimSpace`が不要
```go
if strings.TrimSpace(currentPath) == "" { return }
```
ファイルパスに先頭・末尾スペースが付くことは通常ない。単純に`currentPath == ""`と書くべき。

---

### S-6: `app_input_history.go` — PID桁数差でlexicographicソートが作成時刻順を保証しないケース
コメントに「timestamp prefixが順序を保証する」と書かれているが、同一秒に`PID=9`と`PID=10`のプロセスが起動した場合（`"...10.jsonl"` < `"...9.jsonl"` の辞書順）で誤りになる。稀なケースだがコメントの修正が必要。

---

### S-7: `app_input_history.go` — `processInputString`のベンチマークテスト欠如
1キー入力ごとに呼ばれる高頻度関数にもかかわらずベンチマークテストがない。`go test -bench`で性能リグレッション検出のために追加を推奨。

---

### S-8: `myT-x/frontend/src/components/settings/settingsValidation.ts` — 3重以上の重複時のMapが更新されないロジックを非自明
```typescript
if (conflictViewId) {
    errors[errorKey] = "...";
    errors[`viewer_shortcut_${conflictViewId}`] = "...";
} else {
    seenShortcuts.set(normalized, viewId); // conflict時はMapを未更新
}
```
3つ以上が同一ショートカットを持つ場合、Mapには最初のviewIdのみが残るが結果的に全件にエラーが付くため動作は正しい。ただし意図を示すコメントを1行追加することを推奨。

---

### S-9: `myT-x/frontend/src/components/settings/ViewerShortcutSettings.tsx` — ラベルが英語（UIの言語不統一）
既存の`KeybindSettings.tsx`のラベルは日本語（「垂直分割」「水平分割」等）だが、`ViewerShortcutSettings.tsx`のラベルは英語（"File Tree", "Git Graph"等）。設定画面全体の言語統一の観点から日本語化を検討。

---

### S-10: `useBackendSync.ts` — 同一値定数が分離されている
```typescript
const ERROR_LOG_DEBOUNCE_MS = 80;
const INPUT_HISTORY_DEBOUNCE_MS = 80;       // 同じ80
const ERROR_LOG_FETCH_RETRY_DELAY_MS = 250;
const INPUT_HISTORY_FETCH_RETRY_DELAY_MS = 250; // 同じ250
```
意図的に分ける（独立してチューニング可能にする）ならコメントで明示すること。

---

### S-11: `useInputHistory.ts` — `registerBodyElement`の依存配列への不要な包含
```typescript
}, [entries.length, registerBodyElement]); // registerBodyElementは参照不変
```
`registerBodyElement`は`useCallback(() => {...}, [])`で不変参照のため依存配列に入れても効果なし。`react-hooks/exhaustive-deps`は検出しないが読者を混乱させる。コメントで意図を明示するか削除すること。

---

## Positive（良い点）

### Go Backend
- **ロック解放後のI/Oパターンが徹底**: `writeInputHistoryEntry`/`writeSessionLogEntry`ともにミューテックス解放後に`emit`を行い、ロック保持時間が最小限
- **`sessionLogMu`の設計を`inputHistoryMu`で忠実に踏襲**: ファイルクリーンアップ・リングバッファ・エミットスロットリング・TeeHandlerデッドロック回避まで一貫したパターン
- **`strings.CutPrefix`/`strings.SplitSeq`の採用**: Go 1.24+イディオムを適切に活用。二重探索排除と中間スライスアロケーション削減
- **`processInputString`のESCシーケンス除去**: CSI/OSC/SS3それぞれの終端処理が正確に実装されパニックしない
- **`LogFrontendEvent`の入力バリデーション**: ルーン単位での長さ制限、JSONLインジェクション防止、ファイルパーミッション`0o600`適切
- **リングバッファ実装が正確**: 2-segmentコピーアルゴリズムがバグなく実装

### Go Tests
- **`TestNormalizeLogLevel`**: 大文字・エイリアス・空文字・空白のみ・前後空白付きを網羅
- **`TestConfigStructFieldCounts`**: フィールド数ガードが`12`に更新され、フィールド追加の漏れを早期検出
- **`utf8.ValidString`によるUTF-8妥当性チェックをテストに含め適切**
- **`Clone()`に`ViewerShortcuts`のディープコピーが正しく追加**: `maps.Copy`使用、nullガード適切

### Frontend
- **useBackendSync.ts**: "ping + fetch" + seqによるstale response防止 + 最大1回リトライの対称パターンが完全踏襲
- **inputHistoryStore.ts**: バックエンドリスタート時のseq regression検出とreadマーカーリセットが堅牢。初回ロードでの「全既読扱い」も適切
- **viewerRegistry.ts**: `Symbol.for()`によるHMR越しのregistry保持が正しく実装
- **main.tsx**: `Symbol.for("mytx.global.error.handlers")`によるHMR時の重複リスナー防止は適切なパターン
- **`InputHistoryView.tsx`**: `error-log`とCSSクラスを共有し視覚的一貫性を維持。`bodyRefCallback`でのクリーンアップ管理が正しい設計
- **`settings/seenShortcuts`に`Map<string, string>`を使い正規化した上で重複検査する実装は効率的かつ正確**

---

## タスク修正表（作業者向け並列作業ガイド）

以下の表に従って、修正作業を効率よく並列で実施してください。

| # | タスク | ファイル | 重大度 | 他タスクとの依存関係 | 並列作業可否 |
|---|--------|---------|--------|-------------------|-----------:|
| T-01 | `helpers.go`: `new(v)` → `return &v` に修正し`go:fix inline`保持 | `internal/testutil/helpers.go` | **Critical** | T-02に依存される | ✅ 単独で先行実施 |
| T-02 | `app_session_api_test.go`: `new(true/false)` → `testutil.Ptr(true/false)` に差し戻し（4箇所） | `app_session_api_test.go` | **Critical** | T-01完了後でもT-01と並列可 | ✅ T-03,T-04と並列可 |
| T-03 | `command_router_env_test.go`: `new(true/false)` → `testutil.Ptr()` 差し戻し + `testutil` import 復元（14箇所） | `internal/tmux/command_router_env_test.go` | **Critical** | T-01完了後でもT-01と並列可 | ✅ T-02,T-04と並列可 |
| T-04 | `command_router_handlers_window_test.go`: `new(true/false)` → `testutil.Ptr()` 差し戻し + `testutil` import 復元（2箇所） | `internal/tmux/command_router_handlers_window_test.go` | **Critical** | T-01完了後でもT-01と並列可 | ✅ T-02,T-03と並列可 |
| T-05 | `settingsValidation.ts`: `import`文をファイル先頭に移動 | `frontend/src/components/settings/settingsValidation.ts` | **Critical** | なし | ✅ T-01〜T-04と並列可 |
| T-06 | `app_input_history.go`: タイマージェネレーションカウンタ方式に修正（flushLineBuffer競合バグ修正） | `app_input_history.go`, `app_input_history_types.go` | **Important** | なし | ✅ T-01〜T-05と並列可 |
| T-07 | `app_lifecycle.go`: `initInputHistory()`をTeeHandler設定後に移動 | `app_lifecycle.go` | **Important** | なし | ✅ T-06と並列可 |
| T-08 | `app_session_log_test.go`: メッセージ検証と空白trimテストケースを追加 | `app_session_log_test.go` | **Important** | なし | ✅ T-06,T-07と並列可 |
| T-09 | `app_input_history_test.go`: タイマーキャンセルテストと並行テスト内容検証を追加 | `app_input_history_test.go` | **Important** | T-06のAPI変更後 | ⚠️ T-06完了後に実施 |
| T-10 | `config.go`: `ViewerShortcuts`のバリデーション追加（空キー・不明ビューID等） | `internal/config/config.go` | **Important** | なし | ✅ T-01〜T-05と並列可 |
| T-11 | Settings: `VIEWER_SHORTCUTS`定数を共有ファイルに集約し二重定義解消 | `settingsValidation.ts`, `ViewerShortcutSettings.tsx`, `types.ts` | **Important** | T-05完了後 | ⚠️ T-05完了後に実施 |
| T-12 | `useInputHistory.ts`: 初回表示のスクロール不発修正（bodyRefCallback内でスクロール） | `frontend/.../useInputHistory.ts` | **Important** | なし | ✅ フロントエンドT内で並列可 |
| T-13 | `InputHistoryView.tsx`: `useLayoutEffect` → `useEffect` に変更 | `frontend/.../InputHistoryView.tsx` | **Important** | なし | ✅ T-12と並列可 |
| T-14 | `ErrorBoundary.tsx`: componentStack先頭行のfindによる空行スキップ修正 | `frontend/src/components/ErrorBoundary.tsx` | **Important** | なし | ✅ T-12,T-13と並列可 |
| T-15 | `ActivityStrip.tsx`: ビューIDハードコード解消（ViewPluginに`useUnreadCount`フック追加） | `ActivityStrip.tsx`, `viewerRegistry.ts`, `inputHistoryStore.ts`, `errorLogStore.ts` | **Important** | なし | ⚠️ 影響範囲大・慎重に |
| T-16 | `app_input_history.go`: `cleanupOldInputHistory`の`TrimSpace`を`== ""`に変更 | `app_input_history.go` | Suggestion | なし | ✅ T-06と同時に実施可 |
| T-17 | `app_input_history.go`: PIDソートコメント修正 | `app_input_history.go` | Suggestion | なし | ✅ T-06,T-16と同時に実施可 |
| T-18 | `app_input_history.go`: `processInputString`コメント補記（\x7f暗黙通過の明示） | `app_input_history.go` | Suggestion | なし | ✅ T-16,T-17と同時に実施可 |
| T-19 | `ViewerShortcutSettings.tsx`: ラベルの日本語化 | `ViewerShortcutSettings.tsx` | Suggestion | T-11完了後 | ⚠️ T-11完了後に実施 |
| T-20 | `viewerRegistry.ts`: HMR disposeからnotify除去（開発時アイコンフリッカー防止） | `viewerRegistry.ts` | Suggestion | なし | ✅ 単独で実施可 |
| T-21 | `app_input_history_test.go`: ベンチマークテスト追加 | `app_input_history_test.go` | Suggestion | T-06完了後 | ⚠️ T-09と同時にT-06完了後 |

### 推奨作業グループ（並列作業）

**グループ1（即時・最優先・並列OK）**: T-01, T-02, T-03, T-04, T-05
- T-01はGoのコンパイルエラー修正（単独先行も可）
- T-02〜T-04はT-01と並列で実施可能（`new(true/false)`の単純なテキスト差し戻し）
- T-05はフロントエンドのimport文移動（完全独立）

**グループ2（バックエンド修正・並列OK）**: T-06, T-07, T-08, T-10, T-16, T-17, T-18
- T-06はCore競合バグ修正（最も複雑）
- T-07, T-08, T-10, T-16, T-17, T-18はT-06と並列実施可能

**グループ3（フロントエンド修正・並列OK）**: T-12, T-13, T-14, T-20
- 完全独立なフロントエンド修正

**グループ4（依存あり）**:
- T-09: T-06完了後に実施
- T-11: T-05完了後に実施
- T-15: 影響範囲が大きいため慎重に。グループ2,3完了後が安全
- T-19: T-11完了後に実施
- T-21: T-06, T-09完了後に実施
